import{jsx as e,jsxs as t}from"react/jsx-runtime";import{createStore as a}from"mipd";import{useState as r,useRef as n,useEffect as i,useMemo as o}from"react";import{isAndroid as s}from"react-device-detect";import{getAddress as l}from"viem/utils";import{CustomJwtAccountFlow as c}from"./auth-flows/custom-jwt-account.mjs";import{UpdateEmailFlow as d,EmailFlow as u}from"./auth-flows/email.mjs";import{FarcasterFlow as h}from"./auth-flows/farcaster.mjs";import{GuestFlow as p}from"./auth-flows/guest.mjs";import{PasskeyFlow as w}from"./auth-flows/passkey.mjs";import{SiweFlow as m}from"./auth-flows/siwe.mjs";import{SiwsFlow as y}from"./auth-flows/siws.mjs";import{UpdateSmsFlow as g,SmsFlow as f}from"./auth-flows/sms.mjs";import{TelegramAuthFlow as E,convertInitDataRawToTelegramWebAppData as A,detectCompletingTelegramFlow as _}from"./auth-flows/telegram.mjs";import{v4 as T}from"uuid";import{AccessToken as v}from"./accessToken.mjs";import{getEntropyDetailsFromAccount as C,convertUserResponseToUser as I,getPrivySolanaHDWallets as k,getImportedPrivySolanaWallet as W,getPrivyPrimaryWallet as N,getPrivyEthereumWallet as b,getPrivyEthereumHDWallets as U,getImportedPrivyEthereumWallet as O,shouldProceedtoEmbeddedWalletCreationFlow as S,getPrivySolanaWallet as R,getLatestPrivyEthereumWallet as P,getSolanaSigningAndRootWallet as D,getEthereumSigningAndRootWallet as M,getLatestPrivySolanaWallet as L,getEntropyDetailsFromUser as F}from"./client/user.mjs";import x from"eventemitter3";import{CONNECTORS_STATE_KEY as j,CONNECTIONS_HISTORY_KEY as B,DEFAULT_PRIVY_API_URL as V,DEFAULT_API_TIMEOUT_MS as H,CLIENT_ANALYTICS_ID_KEY as K,CUSTOMER_ACCESS_TOKEN_STORAGE_KEY as z,PRIVY_ACCESS_TOKEN_STORAGE_KEY as G,getGuestCredentialStorageKey as q,HEADLESS_OAUTH_KEY as $,OAUTH_DISABLE_SIGNUP_KEY as Y,STATE_CODE_KEY as X,WALLET_PROXY_TIMEOUT as Q,FORKED_TOKEN_STORAGE_KEY as J}from"./constants.mjs";import Z,{isLocalStorageAccessible as ee}from"./storage.mjs";import{generateTypedDataWithDomainType as te,toHex as ae,detectInjectedConnectors as re,formatChainIdToCAIP2 as ne}from"./utils/index.mjs";import{CoinbaseWalletConnector as ie}from"./connectors/coinbase.mjs";import{EmbeddedWalletConnector as oe}from"./connectors/embedded.mjs";import{isSupportedEthereumRpcMethod as se}from"./embedded-wallets/rpc/types.mjs";import{Captcha as le}from"./components/Captcha.mjs";import{LoginModal as ce}from"./components/LoginModal.mjs";import{TelegramLoginButton as de}from"./components/TelegramLoginButton.mjs";import{PrivyAppConfigProvider as ue,useAppConfig as he,useIsServerConfigLoaded as pe}from"./configuration/context.mjs";import{areWalletArraysEqual as we}from"./connectors/areWalletArraysEqual.mjs";import{PrivyProviderRpcError as me}from"./connectors/errors.mjs";import{isPhantomInstalled as ye}from"./connectors/is-wallet-installed.mjs";import{isBaseConnectedEthereumWallet as ge}from"./connectors/isBaseConnectedEthereumWallet.mjs";import{isSolanaWalletConnector as fe,isBaseConnectedSolanaWallet as Ee}from"./connectors/solana/index.mjs";import{WalletConnectV2WalletConnector as Ae}from"./connectors/walletconnect-v2.mjs";import{EmbeddedWalletIframe as _e}from"./embedded-wallets/EmbeddedWalletIframe.mjs";import{isWalletDelegated as Te,getDelegatedWalletsData as ve,getRootWalletDataForDelegation as Ce,getDelegatedWalletsForUser as Ie}from"./embedded-wallets/delegated-actions.mjs";import{errorIndicatesRecoveryIsNeeded as ke}from"./embedded-wallets/errors.mjs";import{signTransaction as We,sendTransaction as Ne}from"./embedded-wallets/rpc/index.mjs";import{PrivyClientError as be,formatApiError as Ue,formatPrivyError as Oe,PrivyErrorCode as Se,PrivyNotReadyError as Re,PrivyConnectorError as Pe,PrivyError as De}from"./errors.mjs";import{signSolanaTransaction as Me,sendSolanaTransaction as Le}from"./embedded-wallets/solana/transaction.mjs";import{extractChainIdFromCAIP2 as Fe}from"./lib/caip2.mjs";import{USE_BROADCAST_CHANNEL_EVENT_TYPE as xe,isPrivyTheOAuthProvider as je,CROSS_APP_BROADCAST_CHANNEL_NAME as Be}from"./lib/cross-app/index.mjs";import{getCrossAppAuthorizationUrl as Ve,authenticateCrossAppAccount as He,getProviderAppMetadata as Ke}from"./lib/cross-app/authFlow.mjs";import{popupCrossAppAuthFlow as ze}from"./lib/cross-app/popupCrossAppAuthFlow.mjs";import{sendCrossAppRequest as Ge}from"./lib/cross-app/sendCrossAppRequest.mjs";import{getRecoveryAuthorizationUrl as qe,authenticateRecovery as $e,embeddedWalletRecoveryScreen as Ye,toEmbeddedWalletSetRecoveryScreen as Xe}from"./lib/embeddedWalletRecovery.mjs";import{FUNDING_SCREENS as Qe,fundingScreenMethodMap as Je}from"./lib/funding/index.mjs";import{isFundingEnabled as Ze}from"./lib/funding/isFundingEnabled.mjs";import et from"./lib/isEmbeddedWebview.mjs";import{triggerPopup as tt}from"./lib/popup/triggerPopup.mjs";import{popupOAuthFlow as at}from"./lib/popupOAuthFlow.mjs";import{prepareSiweMessageWithNonce as rt}from"./lib/siwe.mjs";import{hasSufficientFunds as nt,createSolanaTransactionReceipt as it}from"./lib/solana/transaction.mjs";import{toDisplayFromAccountType as ot}from"./lib/toDisplayFromAccountType.mjs";import{prepareTransactionRequest as st}from"./lib/viem/prepareTransactionRequest.mjs";import{transformResponseToSnakeCase as lt}from"./passkeys/transformResponseToSnakeCase.mjs";import{PrivyPluginProvider as ct,usePlugins as dt}from"./plugins/context/PrivyPluginContext.mjs";import{SOLANA_FUNDING_PLUGIN_ID as ut}from"./plugins/solana-funding/id.mjs";import{RecentlyUsedAccountProvider as ht}from"./recent-login/context.mjs";import{ModalScreen as pt}from"./screens/index.mjs";import{Hide as wt}from"./screens/LandingScreen/styles.mjs";import{GlobalStyle as mt}from"./styles.mjs";import{getPublicClient as yt}from"./utils/eth/getPublicClient.mjs";import{notImplemented as gt}from"./hooks/index.mjs";import{CaptchaProvider as ft}from"./hooks/captcha-context.mjs";import{privyEventsDefault as Et,emitPrivyEvent as At,PrivyEventsContext as _t}from"./hooks/events-context.mjs";import{InternalPrivyContext as Tt}from"./hooks/internal-context.mjs";import{ModalProvider as vt}from"./hooks/modal-context.mjs";import{PrivyContext as Ct}from"./hooks/privy-context.mjs";import{UseWalletsContext as It}from"./hooks/useWallets.mjs";import{prepareSolanaFundingModalData as kt,prepareFundingModalData as Wt}from"./lib/funding/prepareFundingModalData.mjs";import{detectCompletingOAuthFlow as Nt}from"./auth-flows/oauth/detectCompletingOAuthFlow.mjs";import{OAuthFlow as bt}from"./auth-flows/oauth/OAuthFlow.mjs";import{toViemTransactionSerializable as Ut}from"./lib/viem/toViemTransactionSerializable.mjs";import{getRpcTimeout as Ot}from"./connectors/getRpcTimeout.mjs";import{EmbeddedProviderError as St}from"./connectors/providerTypes.mjs";import{isEthereumWalletConnector as Rt}from"./connectors/ethereum/index.mjs";import{LegacyInjectedWalletConnector as Pt,Injected6963WalletConnector as Dt}from"./connectors/injected.mjs";import{MetamaskWalletConnector as Mt}from"./connectors/metamask.mjs";import{PhantomEthereumNullWalletConnector as Lt}from"./connectors/phantom.mjs";import{PhantomSolanaNullWalletConnector as Ft}from"./connectors/phantom-solana.mjs";import{PrivyProxyProvider as xt}from"./connectors/privyProxyProvider.mjs";import{Http as jt}from"./http.mjs";import{getPaymasterContext as Bt}from"./lib/smart-wallet-helpers.mjs";import{transformOptionsToCamelCase as Vt}from"./passkeys/transformOptionsToCamelCase.mjs";import{mfaPasswordlessSmsInitPath as Ht,mfaPasskeyInitPath as Kt,acceptTermsPath as zt,unlinkEmailPath as Gt,unlinkPhonePath as qt,unlinkWalletPath as $t,siwsUnlinkWalletPath as Yt,unlinkOAuthPath as Xt,unlinkFarcasterPath as Qt,telegramAccountUnlinkPath as Jt,unlinkPasskeyPath as Zt,delegatedActionsRevokePath as ea,analyticsEventsPath as ta,moonpayPluginOnRampPath as aa,coinbaseOnRampInitPath as ra,coinbaseOnRampStatusPath as na,siweInitPath as ia,siweAuthenticatePath as oa,siweLinkPath as sa,smartWalletLinkPath as la,siwsInitPath as ca,siwsAuthenticatePath as da,transferOAuthPath as ua,telegramAccountTransferPath as ha,transferFarcasterPath as pa,transferWalletPath as wa,transferPhonePath as ma,transferEmailPath as ya,siwsLinkPath as ga}from"./paths.mjs";import{AccessTokenTypes as fa,Session as Ea}from"./session.mjs";class Aa extends x{async handleSendTransaction(e){if(!e.params||!Array.isArray(e.params))throw new St(`Invalid params for ${e.method}`,4200);let t=e.params[0];if(!await Fa()||!this.address)throw new St("Disconnected",4900);let{hash:a}=await Va(t,{address:this.address});return a}async handleSignTransaction(e){if(!e.params||!Array.isArray(e.params))throw new St(`Invalid params for ${e.method}`,4200);let t=e.params[0];if(!await Fa()||!this.address)throw new St("Disconnected",4900);let{signature:a}=await Ba(t,{address:this.address});return a}handleSwitchEthereumChain(e){let t;if(!e.params||!Array.isArray(e.params))throw new St(`Invalid params for ${e.method}`,4200);if("string"==typeof e.params[0])t=e.params[0];else{if(!("chainId"in e.params[0])||"string"!=typeof e.params[0].chainId)throw new St(`Invalid params for ${e.method}`,4200);t=e.params[0].chainId}this.chainId=Number(t),this.publicClient=yt(this.chainId,this.chains,this.rpcConfig,{appId:this.appId}),this.emit("chainChanged",t)}async handlePersonalSign(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for personal_sign");let t=e.params[0],a=e.params[1],{signature:r}=await xa({message:t},{address:a});return r}async handleSignedTypedData(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for eth_signTypedData_v4");let t=e.params[0],a="string"==typeof e.params[1]?JSON.parse(e.params[1]):e.params[1],{signature:r}=await ja(te(a),{address:t});return r}async handleEstimateGas(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for eth_estimateGas");delete e.params[0].gasPrice,delete e.params[0].maxFeePerGas,delete e.params[0].maxPriorityFeePerGas;let t={...e.params[0],chainId:ae(this.chainId)};return await this.publicClient.estimateGas({account:t.from??this.address,...Ut(t)})}async request(e){switch(console.debug("Embedded1193Provider.request() called with args",e),e.method){case"eth_accounts":case"eth_requestAccounts":return this.address?[this.address]:[];case"eth_chainId":return ae(this.chainId);case"eth_estimateGas":return this.handleEstimateGas(e);case"eth_sendTransaction":return this.handleSendTransaction(e);case"eth_signTransaction":return this.handleSignTransaction(e);case"wallet_switchEthereumChain":return this.handleSwitchEthereumChain(e);case"personal_sign":return this.handlePersonalSign(e);case"eth_signTypedData_v4":return this.handleSignedTypedData(e)}if(!se(e.method))return this.publicClient.request({method:e.method,params:e.params});{let t=await Fa();if(await Ha(),!t||!this.address)throw new St("Disconnected",4900);try{return(await this.walletProxy.rpc({accessToken:t,entropyId:this.entropyId,entropyIdVerifier:this.entropyIdVerifier,chainType:"ethereum",hdWalletIndex:this.walletIndex,request:{method:e.method,params:e.params}})).response.data}catch(e){throw console.error(e),new St("Disconnected",4900)}}}constructor({walletProxy:e,address:t,entropyId:a,entropyIdVerifier:r,rpcConfig:n,chains:i,appId:o,chainId:s=1,walletIndex:l}){super(),this.walletProxy=e,this.address=t,this.entropyId=a,this.entropyIdVerifier=r,this.chainId=s,this.rpcConfig=n,this.chains=i,this.publicClient=yt(s,this.chains,n,{appId:o}),this.rpcTimeoutDuration=Ot(n,"privy"),this.appId=o,this.walletIndex=l}}class _a extends x{get wallets(){let e=new Set,t=this.walletConnectors.flatMap((e=>e.wallets)).sort(((e,t)=>e.connectedAt&&t.connectedAt?t.connectedAt-e.connectedAt:0)).filter((t=>{let a=`${t.address}${t.walletClientType}${t.connectorType}`;return!e.has(a)&&(e.add(a),!0)})),a=t.findIndex((e=>e.address===(this.activeWallet?this.activeWallet:"unknown")));return a>=0&&t.unshift(t.splice(a,1)[0]),t}async initialize(){if(this.initialized)return;Z.get(j)&&(Z.getKeys().forEach((e=>{e.startsWith("walletconnect")&&Z.del(e)})),Z.del(j));let e=re({store:this.store,walletList:this.walletList,externalWalletConfig:this.externalWalletConfig,walletChainType:this.walletChainType}).then((e=>{e.forEach((({type:e,eip6963InjectedProvider:t,legacyInjectedProvider:a})=>{this.createEthereumWalletConnector("injected",e,{eip6963InjectedProvider:t,legacyInjectedProvider:a})}))}));this.walletList.includes("coinbase_wallet")&&this.createEthereumWalletConnector("coinbase_wallet","coinbase_wallet"),!ye()&&this.walletList.includes("phantom")&&(["ethereum-only","ethereum-and-solana"].includes(this.walletChainType)&&this.createEthereumWalletConnector("phantom","phantom"),["ethereum-and-solana","solana-only"].includes(this.walletChainType)&&this.addWalletConnector(new Ft)),this.externalWalletConfig.walletConnect.enabled&&this.createEthereumWalletConnector("wallet_connect_v2","unknown"),this.externalWalletConfig.solana.connectors?.get().forEach(this.addSolanaWalletConnector),this.externalWalletConfig.solana.connectors?._setOnConnectorsUpdated?.((e=>{e?.forEach(this.addSolanaWalletConnector)})),await e,this.initialized=!0}findWalletConnector(e,t){return"wallet_connect_v2"===e?this.walletConnectors.filter(Rt).find((t=>t.connectorType===e))??null:this.walletConnectors.filter(Rt).find((a=>a.connectorType===e&&a.walletClientType===t))??null}findSolanaWalletConnector(e,t){return this.walletConnectors.filter(fe).find((a=>a.connectorType===e&&a.walletClientType===t))??null}findEmbeddedWalletConnectors(){return this.walletConnectors.filter((e=>"embedded"===e.connectorType))}onInitialized(e){e.wallets.forEach((e=>{let t=this.storedConnections.find((t=>t.address===e.address&&t.connectorType===e.connectorType&&t.walletClientType===e.walletClientType));t&&(e.connectedAt=t.connectedAt)})),this.saveConnectionHistory(),this.emit("walletsUpdated"),this.emit("connectorInitialized")}onWalletsUpdated(e){e.initialized&&(this.saveConnectionHistory(),this.emit("walletsUpdated"))}addEmbeddedWalletConnectors({walletProxy:e,rootWallet:t,embeddedWallets:a,defaultChain:r,appId:n}){for(let i of a){let a=this.findEmbeddedWalletConnectors().find((e=>e.walletIndex===i.walletIndex));if(a&&Rt(a))a.proxyProvider.walletProxy=e;else{let{entropyId:a,entropyIdVerifier:o}=C(t),s=new oe({provider:new Aa({walletProxy:e,address:i.address,entropyId:a,entropyIdVerifier:o,rpcConfig:this.rpcConfig,chains:this.chains,appId:n,chainId:r.id,walletIndex:i.walletIndex}),chains:this.chains,defaultChain:r,rpcConfig:this.rpcConfig,imported:!1,walletIndex:i.walletIndex});this.addWalletConnector(s)}}}addImportedWalletConnector(e,t,a,r){let n=this.findWalletConnector("embedded_imported","privy");if(n&&Rt(n))n.proxyProvider.walletProxy=e;else{let n=new oe({provider:new Aa({walletProxy:e,address:t,entropyId:t,entropyIdVerifier:"ethereum-address-verifier",walletIndex:0,rpcConfig:this.rpcConfig,chains:this.chains,appId:r,chainId:a.id}),chains:this.chains,walletIndex:0,defaultChain:a,rpcConfig:this.rpcConfig,imported:!0});this.addWalletConnector(n)}}removeEmbeddedWalletConnectors(){this.walletConnectors=this.walletConnectors.filter((e=>"embedded"!==e.connectorType)),this.saveConnectionHistory(),this.storedConnections=Ta(),this.emit("walletsUpdated")}removeImportedWalletConnector(){let e=this.findWalletConnector("embedded_imported","privy");if(e){let t=this.walletConnectors.indexOf(e);this.walletConnectors.splice(t,1),this.saveConnectionHistory(),this.storedConnections=Ta(),this.emit("walletsUpdated")}}async createEthereumWalletConnector(e,t,a){let r=this.findWalletConnector(e,t);if(r&&Rt(r))return r instanceof Ae&&r.resetConnection(t),r;let n=(()=>"injected"!==e?"coinbase_wallet"===e?new ie(this.chains,this.defaultChain,this.rpcConfig,this.externalWalletConfig,this.privyAppName,this.privyAppLogo):"phantom"===e?new Lt(this.defaultChain):new Ae(this.walletConnectCloudProjectId,this.rpcConfig,this.chains,this.defaultChain,this.shouldEnforceDefaultChainOnConnect,this.privyAppId,this.privyAppName,t):"metamask"===t&&a?.eip6963InjectedProvider?new Mt(this.chains,this.defaultChain,this.rpcConfig,a?.eip6963InjectedProvider,"metamask"):"metamask"===t&&a?.legacyInjectedProvider?new Pt(this.chains,this.defaultChain,this.rpcConfig,a?.legacyInjectedProvider,"metamask"):"phantom"===t&&a?.legacyInjectedProvider?new Pt(this.chains,this.defaultChain,this.rpcConfig,a?.legacyInjectedProvider,"phantom"):a?.legacyInjectedProvider&&"unknown_browser_extension"===t?new Pt(this.chains,this.defaultChain,this.rpcConfig,a?.legacyInjectedProvider):a?.eip6963InjectedProvider?new Dt(this.chains,this.defaultChain,this.rpcConfig,a?.eip6963InjectedProvider,t):void 0)();return n&&this.addWalletConnector(n),n||null}addWalletConnector(e){this.walletConnectors.push(e),e.on("initialized",(()=>this.onInitialized(e))),e.on("walletsUpdated",(()=>this.onWalletsUpdated(e))),e.initialize().catch((e=>{console.debug("Failed to initialize connector",e)}))}saveConnectionHistory(){let e=this.wallets.map((e=>({address:e.address,connectorType:e.connectorType,walletClientType:e.walletClientType,connectedAt:e.connectedAt})));Z.put(B,e)}async activeWalletSign(e){let t=this.wallets,a=t.length>0?t[0]:null;return a&&ge(a)?a.sign(e):null}setActiveWallet(e){this.activeWallet=l(e),this.emit("walletsUpdated")}constructor(e,t,a,r,n,i,o,s,l,c,d,u){super(),this.addSolanaWalletConnector=async e=>{this.findSolanaWalletConnector("solana_adapter",e.walletClientType)||this.addWalletConnector(e)},this.getEthereumProvider=()=>{let e=this.wallets[0],t=this.walletConnectors.find((t=>t.wallets.find((t=>t.address===e?.address))));return e&&t?t.proxyProvider:new xt},this.privyAppId=e,this.walletConnectCloudProjectId=t,this.rpcConfig=a,this.chains=r,this.defaultChain=n,this.walletConnectors=[],this.initialized=!1,this.store=i,this.walletList=o,this.shouldEnforceDefaultChainOnConnect=s,this.externalWalletConfig=l,this.privyAppName=c,this.privyAppLogo=d,this.walletChainType=u||"ethereum-only",this.storedConnections=Ta()}}const Ta=()=>{let e=Z.get(B);return e&&Array.isArray(e)&&e.map((e=>(e=>e&&"string"==typeof e.address&&"string"==typeof e.connectorType&&"string"==typeof e.walletClientType&&"number"==typeof e.connectedAt)(e))).every(Boolean)?e:[]};let va;var Ca=0,Ia="__private_"+Ca+++"__getOrGenerateClientAnalyticsId";class ka{initializeConnectorManager({walletConnectCloudProjectId:e,rpcConfig:t,chains:a,defaultChain:r,store:n,walletList:i,shouldEnforceDefaultChainOnConnect:o,externalWalletConfig:s,appName:l,walletChainType:c}){this.connectors||(this.connectors=new _a(this.appId,e,t,a,r,n,i,o,s,l,void 0,c))}generateApi(){let e=new jt({appId:this.appId,appClientId:this.appClientId,client:this,defaults:{baseURL:this.apiUrl,timeout:this.timeout}});return this.session.api=e,e}updateApiUrl(e){this.apiUrl=e||this.fallbackApiUrl,this.api=this.generateApi(),e&&(this.useServerCookies=!0)}authenticate(){if(!this.authFlow)throw new be("No auth flow in progress.");return this.session.authenticate(this.authFlow)}async link(){if(!this.authFlow)throw new be("No auth flow in progress.");let{oAuthTokens:e}=await this.session.link(this.authFlow);return{user:await this.getAuthenticatedUser(),oAuthTokens:e}}storeProviderAccessToken(e,t){this.session.storeProviderAccessToken(e,t)}getProviderAccessToken(e){return this.session.getProviderAccessToken(e)}async logout(){await this.session.destroy(),this.authFlow=void 0}clearProviderAcccessTokens(e){e.linkedAccounts.filter((e=>"cross_app"===e.type)).forEach((e=>{this.storeProviderAccessToken(e.providerApp.id,null)}))}startAuthFlow(e){return e.api=this.api,this.authFlow=e,this.authFlow}async initMfaSmsVerification(){try{await this.api.post(Ht,{action:"verify"})}catch(e){throw Ue(e)}}async initMfaPasskeyVerification(){try{let e=await this.api.post(Kt,{});return Vt(e.options)}catch(e){throw Ue(e)}}async getCrossAppProviderDetails(e){try{return this._cachedProviderAppDetails[e]||(this._cachedProviderAppDetails[e]=await this.api.get(`/api/v1/apps/${e}/cross-app/details`)),this._cachedProviderAppDetails[e]}catch(e){console.error("Error fetching cross app provider details",e)}}async acceptTerms(){try{let e=await this.api.post(zt,{});return I(e)}catch(e){throw Oe(e)}}async unlinkEmail(e){try{let t=await this.api.post(Gt,{address:e});return await this.getAuthenticatedUser()??I(t)}catch(e){throw Oe(e)}}async unlinkPhone(e){try{let t=await this.api.post(qt,{phoneNumber:e});return await this.getAuthenticatedUser()??I(t)}catch(e){throw Oe(e)}}async unlinkEthereumWallet(e){try{let t=await this.api.post($t,{address:e});return await this.getAuthenticatedUser()??I(t)}catch(e){throw Oe(e)}}async unlinkSolanaWallet(e){try{let t=await this.api.post(Yt,{address:e});return await this.getAuthenticatedUser()??I(t)}catch(e){throw Oe(e)}}async unlinkOAuth(e,t){try{let a=await this.api.post(Xt,{provider:e,subject:t});return await this.getAuthenticatedUser()??I(a)}catch(e){throw Oe(e)}}async unlinkFarcaster(e){try{let t=await this.api.post(Qt,{fid:e});return await this.getAuthenticatedUser()??I(t)}catch(e){throw Oe(e)}}async unlinkTelegram(e){try{let t=await this.api.post(Jt,{telegram_user_id:e});return await this.getAuthenticatedUser()??I(t)}catch(e){throw Oe(e)}}async unlinkPasskey(e){try{let t=await this.api.post(Zt,{credential_id:e});return await this.getAuthenticatedUser()??I(t)}catch(e){throw Oe(e)}}async revokeDelegatedWallet(){try{await this.api.post(ea,{})}catch(e){throw Oe(e)}}async createAnalyticsEvent({eventName:e,payload:t,timestamp:a,options:r}){if("undefined"!=typeof window)try{this.clientAnalyticsId||console.warn("No client analytics id set, refusing to send analytics event"),await this.api.post(ta,{event_name:e,client_id:this.clientAnalyticsId,payload:{...t||{},clientTimestamp:a?a.toISOString():(new Date).toISOString()}},{retry:-1,keepalive:r?.keepAlive??!1})}catch(e){}}async signMoonpayOnRampUrl(e){try{return this.api.post(aa,e)}catch(e){throw Oe(e)}}async initCoinbaseOnRamp(e){try{return this.api.post(ra,e)}catch(e){throw Oe(e)}}async getCoinbaseOnRampStatus({partnerUserId:e}){try{return this.api.get(`${na}?partnerUserId=${e}`)}catch(e){throw Oe(e)}}async getAuthenticatedUser(){return this.session.hasRefreshCredentials()||this.session.hasRecoveryCredentials()?this.session.refresh():null}async getAccessToken(e){return await this.getPrivyAccessToken(e)||await this.getCustomerAccessToken(e)}async getCustomerAccessToken(e){return await this._getToken(fa.CUSTOMER,e)}async getPrivyAccessToken(e){return await this._getToken(fa.PRIVY,e)}async _getToken(e,t){return this.session.getToken(e)?this.session.hasActiveAccessToken(e)?this.session.hasRefreshCredentials(e)?v.parse(this.session.getToken(e))?.appId!==this.appId?(await this.logout(),null):this.session.getToken(e):(this.session.destroyLocalState(),null):!t?.disableAutoRefresh&&this.session.hasRefreshCredentials(e)?(await this.session.refresh(),this.session.getToken(e)):null:null}async getSmartWalletsConfig(){try{let e={},t=this.session.token;t&&(e.authorization=`Bearer ${t}`);let a=await this.api.get(`/api/v1/apps/${this.appId}/smart_wallets`,{baseURL:this.fallbackApiUrl,headers:e});return a.enabled?{enabled:a.enabled,smartWalletType:a.smart_wallet_type,configuredNetworks:a.configured_networks.map((e=>({chainId:e.chain_id,bundlerUrl:e.bundler_url,paymasterUrl:e.paymaster_url,paymasterContext:Bt(e.paymaster_url,e.paymaster_context)})))}:{enabled:a.enabled}}catch(e){throw Oe(e)}}async getServerConfig(){try{let e={},t=this.session.token;t&&(e.authorization=`Bearer ${t}`);let a=await this.api.get(`/api/v1/apps/${this.appId}`,{baseURL:this.fallbackApiUrl,headers:e}),r=a.telegram_auth_config?{botId:a.telegram_auth_config.bot_id,botName:a.telegram_auth_config.bot_name,linkEnabled:a.telegram_auth_config.link_enabled,seamlessAuthEnabled:a.telegram_auth_config.seamless_auth_enabled}:void 0,n=a.funding_config?{methods:a.funding_config.methods,options:a.funding_config.options,defaultRecommendedAmount:a.funding_config.default_recommended_amount,defaultRecommendedCurrency:a.funding_config.default_recommended_currency,promptFundingOnWalletCreation:a.funding_config.prompt_funding_on_wallet_creation,crossChainBridgingEnabled:a.funding_config.cross_chain_bridging_enabled}:void 0;return{id:a.id,name:a.name,verificationKey:a.verification_key,logoUrl:a.logo_url||void 0,accentColor:a.accent_color||void 0,showWalletLoginFirst:a.show_wallet_login_first,allowlistConfig:{errorTitle:a.allowlist_config.error_title,errorDetail:a.allowlist_config.error_detail,errorCtaText:a.allowlist_config.cta_text,errorCtaLink:a.allowlist_config.cta_link},walletAuth:a.wallet_auth,solanaWalletAuth:a.solana_wallet_auth,emailAuth:a.email_auth,smsAuth:a.sms_auth,googleOAuth:a.google_oauth,twitterOAuth:a.twitter_oauth,discordOAuth:a.discord_oauth,githubOAuth:a.github_oauth,spotifyOAuth:a.spotify_oauth,instagramOAuth:a.instagram_oauth,tiktokOAuth:a.tiktok_oauth,linkedinOAuth:a.linkedin_oauth,appleOAuth:a.apple_oauth,farcasterAuth:a.farcaster_auth,passkeyAuth:a.passkey_auth,passkeysForSignupEnabled:a.passkeys_for_signup_enabled,telegramAuth:a.telegram_auth,disablePlusEmails:a.disable_plus_emails,termsAndConditionsUrl:a.terms_and_conditions_url,embeddedWalletConfig:{createOnLogin:a.embedded_wallet_config?.create_on_login,userOwnedRecoveryOptions:a.embedded_wallet_config.user_owned_recovery_options,requireUserOwnedRecoveryOnCreate:a.embedded_wallet_config.require_user_owned_recovery_on_create},privacyPolicyUrl:a.privacy_policy_url,requireUsersAcceptTerms:a.require_users_accept_terms,customApiUrl:a.custom_api_url,walletConnectCloudProjectId:a.wallet_connect_cloud_project_id,fiatOnRampEnabled:a.fiat_on_ramp_enabled,captchaEnabled:a.captcha_enabled,captchaSiteKey:a.captcha_site_key,createdAt:new Date(1e3*a.created_at),updatedAt:new Date(1e3*a.updated_at),mfaMethods:a.mfa_methods,enforceWalletUis:a.enforce_wallet_uis,legacyWalletUiConfig:a.legacy_wallet_ui_config,telegramAuthConfiguration:r,fundingConfig:n}}catch(e){throw Oe(e)}}async getUsdTokenPrice(e){try{return(await this.api.get(`/api/v1/token_price?chainId=${e.id}&tokenSymbol=${e.nativeCurrency.symbol}`)).usd}catch(t){return void console.error(`Unable to fetch token price for chain with id ${e.id}`)}}async getUsdPriceForSol(){try{return(await this.api.get("/api/v1/token_price?chainId=0&tokenSymbol=SOL")).usd}catch(e){return void console.error("Unable to fetch token price for SOL")}}async getSplTokenMetadata({mintAddress:e,cluster:t}){try{return await this.api.get(`/api/v1/spl_token_info?mint_address=${e}&cluster=${t}`)}catch(a){return void console.error(`Unable to fetch token metadata for ${t}:${e}`)}}async requestFarcasterSignerStatus(e){try{return await this.api.post("/api/v1/farcaster/signer/status",{ed25519_public_key:e})}catch(e){throw console.error("Unable to fetch Farcaster signer status"),e}}async forkSession(){return await this.session.forkSession()}async generateSiweNonce({address:e,captchaToken:t}){try{return(await this.api.post(ia,{address:e,token:t})).nonce}catch(e){throw Oe(e)}}async authenticateWithSiweInternal({message:e,signature:t,chainId:a,walletClientType:r,connectorType:n,mode:i}){return await this.api.post(oa,{message:e,signature:t,chainId:a,walletClientType:r,connectorType:n,mode:i})}async linkWithSiweInternal({message:e,signature:t,chainId:a,walletClientType:r,connectorType:n}){return await this.api.post(sa,{message:e,signature:t,chainId:a,walletClientType:r,connectorType:n})}async linkSmartWallet({message:e,signature:t,smartWalletType:a}){try{let r=await this.api.post(la,{message:e,signature:t,smart_wallet_type:a});return I(r)}catch(e){throw Oe(e)}}async linkWithSiwe({message:e,signature:t,chainId:a,walletClientType:r,connectorType:n}){try{let i=await this.linkWithSiweInternal({message:e,signature:t,chainId:a,walletClientType:r,connectorType:n});return I(i)}catch(e){throw Oe(e)}}async generateSiwsNonce({address:e,captchaToken:t}){try{return(await this.api.post(ca,{address:e,token:t})).nonce}catch(e){throw Oe(e)}}async authenticateWithSiwsInternal({message:e,signature:t,walletClientType:a,connectorType:r,mode:n}){return await this.api.post(da,{message:e,signature:t,walletClientType:a,connectorType:r,mode:n})}async sendAccountTransferRequest({nonce:e,account:t,accountType:a,externalWalletMetadata:r,telegramAuthResult:n,telegramWebAppData:i,farcasterEmbeddedAddress:o,oAuthUserInfo:s}){try{let l,c;switch(a){case"email":l=ya,c={nonce:e,email:t};break;case"sms":l=ma,c={nonce:e,phoneNumber:t};break;case"siwe":if(l=wa,!r)throw Error("Wallet parameters must be defined");c={nonce:e,address:t,...r};break;case"farcaster":l=pa,c={nonce:e,farcaster_id:t,farcaster_embedded_address:o};break;case"telegram":l=ha,c={nonce:e,telegram_auth_result:n,telegram_web_app_data:i};break;case"custom":case"guest":case"passkey":throw Error("Invalid transfer account type");default:l=ua,c={nonce:e,userInfo:s}}let d=await this.api.post(l,c);return await this.getAuthenticatedUser()??I(d)}catch(e){throw Oe(e)}}async linkWithSiwsInternal({message:e,signature:t,walletClientType:a,connectorType:r}){return await this.api.post(ga,{message:e,signature:t,walletClientType:a,connectorType:r})}async linkWithSiws({message:e,signature:t,walletClientType:a,connectorType:r}){try{let n=await this.linkWithSiwsInternal({message:e,signature:t,walletClientType:a,connectorType:r});return I(n)}catch(e){throw Oe(e)}}constructor({apiUrl:e=V,appId:t,appClientId:a,timeout:r=H}){Object.defineProperty(this,Ia,{value:Wa}),this._cachedProviderAppDetails={},this.apiUrl=e,this.fallbackApiUrl=this.apiUrl,this.useServerCookies=e!==V&&e.startsWith("https://privy."),this.timeout=r,this.appId=t,this.appClientId=a,this.clientAnalyticsId=function(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw TypeError("attempted to use private field on non-instance");return e}(this,Ia)[Ia](),va||(va=new Ea),this.session=va,this.api=this.generateApi(),this.session.client=this}}function Wa(){if("undefined"==typeof window)return null;try{let e=Z.get(K);if("string"==typeof e&&e.length>0)return e}catch(e){}let e=T();try{return Z.put(K,e),e}catch(t){return e}}class Na{async handleSignMessage(e){if(!e.params||"string"!=typeof e.params.message)throw Error("Message must be provided as a string for Solana signMessage RPC");return await za({message:e.params.message,address:this.address})}async request(e){if(console.debug("EmbeddedSolanaProvider.request() called with args",e),!await Fa())throw Error("User must be authenticated to use embedded Solana wallet");if(!await Ka())throw new be("Unable to connect to Solana embedded wallet");if("signMessage"===e.method)return await this.handleSignMessage(e);throw Error("Embedded Solana provider does not yet support this RPC method.")}constructor(e,t){this.walletProxy=e,this.address=t}}let ba,Ua,Oa,Sa,Ra,Pa,Da,Ma;function La(){return ba?ba.getCustomerAccessToken():Promise.resolve(Z.get(z)||null)}async function Fa(){return ba?ba.getAccessToken():Promise.resolve(Z.get(G)||Z.get(z)||null)}const xa=(e,t)=>Ua(e,t),ja=(e,t)=>Oa(e,t),Ba=(e,t)=>Sa(e,t),Va=(e,t)=>Ra(e,t),Ha=()=>Pa(),Ka=()=>Da(),za=({message:e,address:t})=>Ma({message:e,address:t});const Ga=({config:t,...a})=>{var r;if("undefined"!=typeof window&&0>["localhost","127.0.0.1"].indexOf(window.location.hostname)&&"https:"!==window.location.protocol)throw new be("Embedded wallet is only available over HTTPS");if("string"!=typeof(r=a.appId)||25!==r.length)throw new be("Cannot initialize the Privy provider with an invalid Privy app ID");ba||(ba=new ka({appId:a.appId,appClientId:a.clientId,apiUrl:a.apiUrl}));let n=Object.assign({},t);/*#__PURE__*/
return e(ue,{client:ba,clientConfig:n,children:/*#__PURE__*/e(ct,{children:/*#__PURE__*/e(qa,{...a,client:ba})})})};let qa=T=>{let v=T.client,I=dt(),[x,j]=r(!1),[B,H]=r(!1),[z,G]=r(!1),[re,ie]=r(null),[oe,se]=r([]),[ue,fe]=r([]),[Ue,Oe]=r([]),[ct,Ut]=r(!1),[Ot,St]=r(null),[Rt,Pt]=r(!1),[Dt,Mt]=r({status:"disconnected",connectedWallet:null,connectError:null,connector:null,connectRetry:gt}),[Lt,Ft]=r({status:"initial"}),[xt,jt]=r({status:"initial"}),[Bt,Vt]=r({status:"initial"}),[Ht,Kt]=r({status:"initial"}),[zt,Gt]=r({status:"initial"}),[qt,$t]=r(null),Yt=he(),Xt=pe(),[Qt,Jt]=r(!0),[Zt,ea]=r({}),[ta,aa]=r(null),[ra,na]=r(null),[ia,oa]=r(!1),[sa,la]=r(!1),[ca,da]=r(Yt.customAuth?.enabled?{status:"initial"}:{status:"not-enabled"}),ua=n(null),ha=n(null),pa=n(Et),[wa,ma]=r(!1);v.onStoreCustomerAccessToken=e=>{e&&At(pa,"accessToken","onAccessTokenGranted",{accessToken:e})},v.onDeleteCustomerAccessToken=()=>{ie(null),G(!1),At(pa,"accessToken","onAccessTokenRemoved")};let ya=n(null),ga=n(null),fa=n(!1),Ea=({showWalletUIs:e})=>fa.current?fa.current:void 0!==e?!e:!Yt.embeddedWallets.showWalletUIs,Aa=e=>{St(e),setTimeout((()=>{j(!0)}),15),v.createAnalyticsEvent({eventName:"modal_open",payload:{initialScreen:e}})},_a=e=>{"off"!==Yt.embeddedWallets.createOnLogin&&Jt(!0),Aa(e)};i((()=>{let e=[...k(re),W(re)].filter((e=>!!e));qt&&Oe(e.map((e=>({type:"solana",imported:e.imported,address:e.address,connectedAt:Date.now(),walletClientType:"privy",connectorType:"embedded",walletIndex:e.walletIndex??void 0,meta:{name:"Privy Wallet",icon:void 0,id:"io.privy.solana.wallet"},linked:!0,fund(){throw new be("'fund' is deprecated for Solana wallets - use 'fundWallet' instead")},unlink:()=>{throw new be("Cannot unlink an embedded Solana wallet")},getProvider:async()=>new Na(qt,e.address),async signMessage(t){let a=await Fa();if(!a||!qt)throw new be("Must have valid access token and Privy wallet to send transaction",Se.MUST_BE_AUTHENTICATED);let r=e.imported?W(re):N(re);if(!r)throw new be("Attempting to sign a transaction without a root wallet");let{entropyId:n,entropyIdVerifier:i}=C(r);if(!await rr.recoverPrimaryWallet().catch((()=>!1)))throw new be("Wallet couldn't be connected",Se.UNKNOWN_CONNECT_WALLET_ERROR);if(!re)throw new be("Attempting to sign a transaction with no user initialized");let{response:o}=await qt.rpc({accessToken:a,entropyId:n,entropyIdVerifier:i,chainType:"solana",hdWalletIndex:e.walletIndex??0,request:{method:"signMessage",params:{message:Buffer.from(t).toString("base64")}}});return Buffer.from(o.data.signature,"base64")},async sendTransaction(e,t,a){let{signature:r}=await Xa({transaction:e,connection:t,transactionOptions:a,wallet:this});return r},async signTransaction(t){let a=await Fa();if(!a||!qt)throw new be("Must have valid access token and Privy wallet to send transaction",Se.MUST_BE_AUTHENTICATED);if(!await rr.recoverPrimaryWallet().catch((()=>!1)))throw new be("Wallet couldn't be connected",Se.UNKNOWN_CONNECT_WALLET_ERROR);let r=e.imported?e:N(re);if(!r)throw new be("Attempting to sign a transaction without a root wallet");let{entropyId:n,entropyIdVerifier:i}=C(r);return await Me({tx:t,accessToken:a,walletProxy:qt,entropyId:n,entropyIdVerifier:i,transactingWalletAddress:this.address,transactingWalletIndex:e.walletIndex??0}),t},loginOrLink:async()=>{throw new be("Cannot login or link with an embedded Solana wallet")},disconnect:()=>{},isConnected:async()=>!0}))))}),[qt,re]),i((()=>{if(!re)return void v.connectors?.removeEmbeddedWalletConnectors();let e=b(re),t=U(re),a=O(re);e&&t.length||v.connectors?.removeEmbeddedWalletConnectors(),a||v.connectors?.removeImportedWalletConnector(),v.connectors?qt?(e&&v.connectors.addEmbeddedWalletConnectors({walletProxy:qt,rootWallet:e,embeddedWallets:t,defaultChain:Yt.defaultChain,appId:T.appId}),a&&v.connectors.addImportedWalletConnector(qt,a.address,Yt.defaultChain,T.appId)):console.debug("Failed to add embedded wallet connector: Wallet proxy not initialized"):console.debug("Failed to add embedded wallet connector: Client connectors not initialized")}),[qt,re]),i((()=>{qt&&ra?.(qt)}),[qt]);let Ta=n();i((()=>{(async()=>{if(!Yt.customAuth?.enabled)return void da({status:"not-enabled"});Jt(!0);let{getCustomAccessToken:e,isLoading:t}=Yt.customAuth;if(B&&!t&&"loading"!==ca.status){da({status:"loading"});try{let t=await e();if(t===Ta.current)return void da({status:"done"});if(!t&&z)return Ta.current=t,await ar.logout(),da({status:"done"}),void At(pa,"customAuth","onUnauthenticated");if(!t)return Ta.current=t,void da({status:"done"});v.startAuthFlow(new c(t));let{user:a,isNewUser:r}=await v.authenticate();if(!a)return await ar.logout(),da({status:"error",error:new be("Failed to sync with custom auth provider")}),void At(pa,"customAuth","onUnauthenticated");void 0!==r&&At(pa,"login","onComplete",{user:a,isNewUser:r,wasAlreadyAuthenticated:!1,loginMethod:"custom",loginAccount:null}),Ta.current=t,At(pa,"customAuth","onAuthenticated",{user:a}),da({status:"done"}),ie(a||null),Ut(r||!1),G(!0),la(!0)}catch(e){if(console.warn(e),await ar.logout(),At(pa,"customAuth","onUnauthenticated"),"User already exists with provided custom JWT account."===e.message)return void da({status:"initial"});At(pa,"login","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR),da({status:"error",error:e})}}})()}),["initial"===ca.status,Yt.customAuth?.enabled,Yt.customAuth?.getCustomAccessToken,Yt.customAuth?.isLoading,B,z]),i((()=>{sa&&qt&&re&&S(re,Yt.embeddedWallets.createOnLogin)&&(la(!1),Ka(re,Q).catch(console.error))}),[sa&&qt&&re]),i((()=>{if(Yt.externalWallets.solana.connectors)return Yt.externalWallets.solana.connectors.onMount(),()=>Yt.externalWallets.solana.connectors?.onUnmount()}),[Yt.externalWallets.solana.connectors]),i((()=>{!B&&Xt&&async function(){let e,t=va(),r=Ca();(()=>{let e=new URLSearchParams(window.location.search).get("privy_token");if(!e)return;Z.put(J,e);let t=new URL(window.location.href);t.searchParams.delete("privy_token"),window.history.pushState({},"",t)})();let n=a();v.initializeConnectorManager({walletConnectCloudProjectId:Yt.walletConnectCloudProjectId,rpcConfig:Yt.rpcConfig,chains:Yt.chains,defaultChain:Yt.defaultChain,store:n,walletList:Yt.appearance.walletList,shouldEnforceDefaultChainOnConnect:Yt.shouldEnforceDefaultChainOnConnect,externalWalletConfig:Yt.externalWallets,appName:Yt.name??"Privy",walletChainType:Yt.appearance.walletChainType}),v.connectors?.on("connectorInitialized",(()=>{e&&clearTimeout(e);let t=v.connectors.walletConnectors.length,a=v.connectors.walletConnectors.reduce(((e,t)=>e+(t.initialized?1:0)),0);a===t?ma(!0):e=setTimeout((()=>{console.debug({message:"Unable to initialize all expected connectors before timeout",initialized:a,expected:t}),ma(!0)}),1500)})),v.connectors?.initialize().then((()=>{xa()}));let i=await v.getAuthenticatedUser(),o=!!i;Yt.legal.requireUsersAcceptTerms&&i&&!i.hasAcceptedTerms?(await v.logout(),rr.setReadyToTrue(!0),At(pa,"logout","onSuccess")):(Yt.customAuth?.enabled||(G(!!i),i&&At(pa,"login","onComplete",{user:i,isNewUser:!1,wasAlreadyAuthenticated:!0,loginMethod:null,loginAccount:null}),ie(i)),t?ga.current=o?"link":"login":r&&!o?(ga.current="login",ea({telegramAuthModalData:{seamlessAuth:!0}}),_a(pt.TELEGRAM_AUTH_SCREEN)):rr.setReadyToTrue(!!i))}()}),[v,ta,B,Xt]),i((()=>{if(B){if(!re||!re.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType)))return void oa(!0);oa([...oe,...Ue].some((e=>"privy"===e.walletClientType)))}}),[B,re,oe,Ue]);let va=()=>{let e=Nt();return e.inProgress&&e.popupFlow?window.opener.location.origin!==window.location.origin?void window.opener.postMessage({type:"PRIVY_OAUTH_ERROR",error:"Origins between parent and child windows do not match."}):"error"===e.authorizationCode?void window.opener.postMessage({type:"PRIVY_OAUTH_ERROR",error:"Something went wrong. Try again."}):void window.opener.postMessage({type:"PRIVY_OAUTH_RESPONSE",stateCode:e.stateCode,authorizationCode:e.authorizationCode}):(e.inProgress&&je(e.provider)&&!e.popupFlow&&(new BroadcastChannel(Be).postMessage({type:"PRIVY_OAUTH_RESPONSE",stateCode:e.stateCode,authorizationCode:e.authorizationCode}),window.close()),!!e.inProgress&&!!e.withPrivyUi&&(v.startAuthFlow(new bt(e)),_a(pt.AWAITING_OAUTH_SCREEN),!0))},Ca=()=>{let e=_();if(!e||!Yt.loginMethods.telegram||!Yt.loginConfig.telegramAuthConfiguration?.seamlessAuthEnabled)return;let t=new E;return v.startAuthFlow(t),"login-url"===e.flowType&&(t.meta.telegramWebAppData=void 0,t.meta.telegramAuthResult=e.authData),"web-app"===e.flowType&&(t.meta.telegramAuthResult=void 0,t.meta.telegramWebAppData=e.authData),!0},Ia=async(e,t,a,r)=>{ka(await(v.connectors?.createEthereumWalletConnector(e,t))||null,t,a,r)};async function ka(e,t,a,r){if(!e)return Mt({status:"disconnected",connectedWallet:null,connectError:new Pe("Unable to connect to wallet."),connector:null,connectRetry:gt}),r?.(null,a);Mt({status:"disconnected",connectedWallet:null,connectError:null,connector:e,connectRetry:gt}),e instanceof Ae&&t&&await e.resetConnection(t),Mt({connector:e,status:"connecting",connectedWallet:null,connectError:null,connectRetry:()=>ka(e,t,a,r)});try{let t=await e.connect({showPrompt:!0});if((!t||ge(t))&&Yt.shouldEnforceDefaultChainOnConnect&&!Yt.chains.find((e=>e.id===Number(t?.chainId.replace("eip155:",""))))&&("wallet_connect_v2"!==t?.connectorType||"metamask"!==t?.walletClientType)){Mt((t=>({...t,connector:e,status:"switching_to_supported_chain",connectedWallet:null,connectError:null,connectRetry:gt})));try{await(t?.switchChain(Yt.defaultChain.id)),t&&(t.chainId=ne(ae(Yt.defaultChain.id)))}catch{console.warn(`Unable to switch to default chain: ${Yt.defaultChain.id}`)}}return Mt((e=>({...e,status:"connected",connectedWallet:t,connectError:null,connectRetry:gt}))),t&&At(pa,"connectWallet","onSuccess",{wallet:t}),r?.(t,a)}catch(e){return e instanceof De?(console.warn(e.cause?e.cause:e.message),At(pa,"connectWallet","onError",e.privyErrorCode||Se.GENERIC_CONNECT_WALLET_ERROR)):(console.warn(e),At(pa,"connectWallet","onError",Se.UNKNOWN_CONNECT_WALLET_ERROR)),Mt((t=>({...t,status:"disconnected",connectedWallet:null,connectError:e}))),r?.(null,a)}}let Wa=async(e,t,a)=>{if(null===e||!ge(e))return;let r=new m(e,v,t,a);v.startAuthFlow(r)},La=async(e,t,a)=>{if(null===e||!Ee(e))return;let r=new y(e,v,t,a);v.startAuthFlow(r)},xa=()=>{let e=new URLSearchParams(window.location.search),t=e.get("privy_connector"),a=e.get("privy_wallet_client");if(!t||!a)return;if("phantom"!==a||ye()||_a(pt.LOGIN_FAILED_SCREEN),!v.connectors)throw new be("Connector not initialized");Aa(pt.AWAITING_CONNECTION);let r=new URL(window.location.href);r.searchParams.delete("privy_connector"),r.searchParams.delete("privy_wallet_client"),window.history.pushState({},"",r),Ia(t,a,void 0,Wa)};i((()=>{B&&z&&null===re&&v.getAuthenticatedUser().then(ie)}),[B,z,re,v]);let ja=e=>{if(!z)throw At(pa,"linkAccount","onError",Se.MUST_BE_AUTHENTICATED,{linkMethod:e}),new be("User must be authenticated before linking an account.")},Ba=e=>{if(!z||!re)return!1;if("privy"===e.walletClientType)return!0;for(let t of re.linkedAccounts)if("wallet"===t.type&&t.address===e.address&&"privy"!==t.walletClientType)return!0;return!1},Va=async e=>{let t;if(!v.connectors)throw new be("Connector not initialized");t="ethereum"===e.type?v.connectors.findWalletConnector(e.connectorType,e.walletClientType)||null:v.connectors.findSolanaWalletConnector(e.connectorType,e.walletClientType)||null,Mt((a=>({...a,connector:t,status:"connected",connectedWallet:e,connectError:null,connectRetry:gt}))),Yt.captchaEnabled&&!z?(ea({captchaModalData:{callback:t=>ge(e)?Wa(e,t):La(e,t),userIntentRequired:!1,onSuccessNavigateTo:pt.AWAITING_CONNECTION,onErrorNavigateTo:pt.ERROR_SCREEN}}),_a(pt.CAPTCHA_SCREEN)):(ge(e)?await Wa(e):await La(e),_a(pt.AWAITING_CONNECTION))},Ha=()=>{se((e=>{let t=v.connectors?.wallets.filter(ge).map((e=>({...e,linked:Ba(e),loginOrLink:async()=>{if(!await e.isConnected())throw new be("Wallet is not connected");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new be("Cannot link or login with embedded wallet");Va(e)},fund:async t=>{await rr.fundWallet(e.address,t)},unlink:async()=>{if(!z)throw new be("User is not authenticated.");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new be("Cannot unlink an embedded wallet");ie(await v.unlinkEthereumWallet(e.address))}})))||[];return we(e,t)?e:t})),fe((e=>{let t=(v.connectors?.wallets??[]).filter(Ee).map((e=>({...e,linked:Ba(e),loginOrLink:async()=>{if(!await e.isConnected())throw new be("Wallet is not connected");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new be("Cannot link or login with embedded wallet");Va(e)},fund:async()=>{throw new be("'fund' is deprecated for Solana wallets - use 'fundWallet' instead")},unlink:async()=>{if(!z)throw new be("User is not authenticated.");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new be("Cannot unlink an embedded wallet");ie(await v.unlinkSolanaWallet(e.address))}})));return we(e,t)?e:t}))};i((()=>{Ha()}),[re?.linkedAccounts,z,B]),i((()=>{if(B){if(!v.connectors)throw new be("Connector not initialized");Ha(),v.connectors.on("walletsUpdated",Ha)}}),[B]),i((()=>{[...Yt.loginMethodsAndOrder?.primary??[],...Yt.loginMethodsAndOrder?.overflow??[]].filter((e=>e.startsWith("privy:"))).forEach((e=>v.getCrossAppProviderDetails(e.replace("privy:",""))))}),[!!v]);let Ka=async(e,t,a)=>{let r=b(e),n=R(e);if(a&&"walletIndex"in a)return Ga(e,t,a.walletIndex,r,n);let i=a&&"createAdditional"in a&&a.createAdditional;if(r&&!i)throw At(pa,"createWallet","onError",Se.EMBEDDED_WALLET_ALREADY_EXISTS),Error("User already has an embedded wallet.");let[o,s]=await Promise.all([rr.initializeWalletProxy(t),Fa()]);if(!o&&Yt.customAuth?.enabled)throw At(pa,"createWallet","onError",Se.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");if(!o||!s||Yt.embeddedWallets?.requireUserOwnedRecoveryOnCreate)return za();if(!r)return n&&await rr.recoverPrimaryWallet(),await o.create({accessToken:s,solanaAddress:n?.address}),$a(0,"ethereum");{let t=(P(e)?.walletIndex??0)+1,{entropyId:a,entropyIdVerifier:r}=C(N(e));return await rr.recoverPrimaryWallet(),await o.addWallet({accessToken:s,entropyId:a,entropyIdVerifier:r,chainType:"ethereum",hdWalletIndex:t}),$a(t,"ethereum")}},za=async()=>new Promise(((e,t)=>{Jt(!0),ea({createWallet:{onSuccess:t=>{At(pa,"createWallet","onSuccess",{wallet:t}),e(t)},onFailure:e=>{At(pa,"createWallet","onError",Se.UNKNOWN_EMBEDDED_WALLET_ERROR),t(e)},callAuthOnSuccessOnClose:!1}}),Aa(pt.EMBEDDED_WALLET_ON_ACCOUNT_CREATE_SCREEN)})),Ga=async(e,t,a,r,n)=>{if(a<0)throw At(pa,"createWallet","onError",Se.EMBEDDED_WALLET_CREATE_ERROR),Error(`A negative walletIndex (${a}) is invalid.`);let[i,o]=await Promise.all([rr.initializeWalletProxy(t),Fa()]);if(!i&&Yt.customAuth?.enabled)throw At(pa,"createWallet","onError",Se.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");if(!i||!o||Yt.embeddedWallets?.requireUserOwnedRecoveryOnCreate){if(0==a)return za();throw At(pa,"createWallet","onError",Se.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Create wallet UI can only be displayed when walletIndex is 0.")}if(0==a){if(r)return r;await i.create({accessToken:o,solanaAddress:n?.address})}else{if(!r)throw At(pa,"createWallet","onError",Se.EMBEDDED_WALLET_CREATE_ERROR),Error("A user must have a wallet at HD index 0 before creating a wallet at greater HD indices.");let t=U(e).find((e=>e.walletIndex===a));if(t)return t;let{entropyId:n,entropyIdVerifier:s}=C(N(e));await rr.recoverPrimaryWallet(),await i.addWallet({accessToken:o,entropyId:n,entropyIdVerifier:s,chainType:"ethereum",hdWalletIndex:a})}return $a(a,"ethereum")},qa=async({user:e,wp:t,accessToken:a,walletIndex:r,ethereumWallet:n})=>{let i=k(e).find((e=>e.walletIndex===r));if(i)return i;if(0===r)n&&await rr.recoverPrimaryWallet(),await t.createSolana({accessToken:a,ethereumAddress:n?.address});else{let n=N(e);if(!n)throw At(pa,"createWallet","onError",Se.EMBEDDED_WALLET_CREATE_ERROR),Error("User must have a wallet at HD index 0 before creating a wallet at greater HD indices.");let{entropyId:i,entropyIdVerifier:o}=C(n);await rr.recoverPrimaryWallet(),await t.addWallet({accessToken:a,entropyId:i,entropyIdVerifier:o,chainType:"solana",hdWalletIndex:r})}return $a(r,"solana")},$a=async(e,t)=>{let a=await rr.refreshUser(),r=("ethereum"===t?U(a):k(a)).find((t=>t.walletIndex===e));if(!r)throw At(pa,"createWallet","onError",Se.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to create wallet");return At(pa,"createWallet","onSuccess",{wallet:r}),r},Ya=({transaction:e,uiOptions:t,fundWalletConfig:a,address:r,signOnly:n})=>new Promise((async(i,o)=>{let{requesterAppId:s}=t||{},c=n?"signTransaction":"sendTransaction";if(!z||!re)return At(pa,c,"onError",Se.MUST_BE_AUTHENTICATED),void o(Error("User must be authenticated before signing with a Privy wallet"));let d=r??b(re)?.address;if(!d)throw new be("User must have an embedded wallet to send a transaction.");let{signingWallet:u,rootWallet:h}=M(re,d);if(!h||!u)return At(pa,c,"onError",Se.EMBEDDED_WALLET_NOT_FOUND),void o(Error("Must have a Privy wallet before signing"));Jt(!0);let p=nr.wallets.find((e=>"privy"===e.walletClientType&&l(e.address)===l(u.address))),w=await(p?.getEthereumProvider());if(!p||!w)throw new be(`Cannot sendTransaction before embedded wallet ${u.address} is connected`);let m=e.chainId?Number(e.chainId):Fe(p.chainId);(e=>{if(!Yt.chains.map((e=>e.id)).includes(e))throw new Pe(`Chain ID ${e} is not supported. It must be added to the config.supportedChains property of the PrivyProvider.`,Se.UNSUPPORTED_CHAIN_ID)})(m);let y={...e,from:e.from??u.address,chainId:m},g=await Fa();if(!g||!qt)return At(pa,c,"onError",Se.EMBEDDED_WALLET_NOT_FOUND),void o(Error("Must have valid access token and Privy wallet to send transaction"));let f=yt(y.chainId,Yt.chains,Yt.rpcConfig,{appId:T.appId});if(Ea({showWalletUIs:t?.showWalletUIs}))(async()=>{try{if(!await rr.recoverPrimaryWallet())return At(pa,c,"onError",Se.UNKNOWN_CONNECT_WALLET_ERROR),void o(Error("Unable to connect to wallet"));let e=await st(y,f,y.from),{entropyId:t,entropyIdVerifier:a}=C(h),r=n?await We({accessToken:g,entropyId:t,entropyIdVerifier:a,transactingWallet:u,walletProxy:qt,transactionRequest:y,requesterAppId:s}):await Ne({accessToken:g,entropyId:t,entropyIdVerifier:a,transactingWallet:u,walletProxy:qt,transactionRequest:e,publicClient:f,requesterAppId:s});n?At(pa,"signTransaction","onSuccess",{signature:r}):At(pa,"sendTransaction","onSuccess",{hash:r}),i({hash:r})}catch(e){At(pa,c,"onError",Se.TRANSACTION_FAILURE),o(e)}})();else{let{entropyId:e,entropyIdVerifier:r}=C(h),l={entropyId:e,entropyIdVerifier:r,onCompleteNavigateTo:pt.EMBEDDED_WALLET_SEND_TRANSACTION_SCREEN,onFailure:e=>{At(pa,c,"onError",Se.UNKNOWN_CONNECT_WALLET_ERROR),o(e)}},d=Ze(Yt)?Wt({address:u.address,appConfig:Yt,fundWalletConfig:a,methodScreen:pt.FUNDING_METHOD_SELECTION_SCREEN,chainIdOverride:y.chainId,comingFromSendTransactionScreen:!0}):void 0;ea({connectWallet:l,sendTransaction:{transactionRequest:y,transactingWallet:u,entropyId:e,entropyIdVerifier:r,signOnly:n,onConfirm:n?async()=>await We({accessToken:g,entropyId:e,entropyIdVerifier:r,transactingWallet:u,walletProxy:qt,transactionRequest:y,requesterAppId:s}):void 0,onSuccess:e=>{n?At(pa,"signTransaction","onSuccess",{signature:e.hash}):At(pa,"sendTransaction","onSuccess",{hash:e.hash}),i(e)},onFailure:e=>{At(pa,c,"onError",Se.TRANSACTION_FAILURE),o(e)},uiOptions:t||{},fundWalletConfig:a,requesterAppId:s},funding:d}),Aa(pt.EMBEDDED_WALLET_CONNECTING_SCREEN)}})),Xa=({transaction:e,connection:t,transactionOptions:a,fundWalletConfig:r,uiOptions:n,wallet:i})=>new Promise((async(o,s)=>{let{requesterAppId:l}=n||{};if(!z||!re)return At(pa,"sendSolanaTransaction","onError",Se.MUST_BE_AUTHENTICATED),void s(new be("User must be authenticated before signing with a Privy wallet",Se.MUST_BE_AUTHENTICATED));let c=i?re.linkedAccounts.find((e=>"wallet"===e.type&&e.address===i.address)):R(re);if(!c)return At(pa,"sendSolanaTransaction","onError",Se.EMBEDDED_WALLET_NOT_FOUND),void s(new be("Must have a Privy wallet before signing",Se.EMBEDDED_WALLET_NOT_FOUND));Jt(!0);let{rootWallet:d}=D(re,c.address);if(!await rr.recoverPrimaryWallet().catch((()=>!1))||!d)throw At(pa,"sendSolanaTransaction","onError",Se.EMBEDDED_WALLET_NOT_FOUND),new be(`Cannot sendSolanaTransaction before embedded wallet ${c.address} is connected`,Se.EMBEDDED_WALLET_NOT_FOUND);if(Ea({showWalletUIs:n?.showWalletUIs}))(async()=>{let r=await Fa();if(!r||!qt)return At(pa,"sendSolanaTransaction","onError",Se.EMBEDDED_WALLET_NOT_FOUND),void s(new be("Must have valid access token and Privy wallet to send transaction",Se.EMBEDDED_WALLET_NOT_FOUND));try{if(!await rr.recoverPrimaryWallet())return At(pa,"sendSolanaTransaction","onError",Se.UNKNOWN_CONNECT_WALLET_ERROR),void s(new be("Unable to connect to wallet",Se.UNKNOWN_CONNECT_WALLET_ERROR));if(Ea({showWalletUIs:n?.showWalletUIs})&&!await nt(e,t))return At(pa,"sendSolanaTransaction","onError",Se.INSUFFICIENT_BALANCE),void s(new be("Solana wallet has insufficient funds for this transaction.",Se.INSUFFICIENT_BALANCE));let{entropyId:i,entropyIdVerifier:l}=F(re),{signature:d,receipt:u}=await Le({accessToken:r,tx:e,connection:t,walletProxy:qt,transactionOptions:a,entropyId:i,entropyIdVerifier:l,transactingWalletAddress:c.address,transactingWalletIndex:c.walletIndex??0}),h=it(d,u);At(pa,"sendSolanaTransaction","onSuccess",{response:h}),o(h)}catch(e){At(pa,"sendSolanaTransaction","onError",Se.TRANSACTION_FAILURE),s(e)}})();else{let{entropyId:i,entropyIdVerifier:u}=C(d),h={entropyId:i,entropyIdVerifier:u,onCompleteNavigateTo:pt.EMBEDDED_WALLET_SEND_SOLANA_TRANSACTION_SCREEN,onFailure:e=>{At(pa,"sendSolanaTransaction","onError",Se.UNKNOWN_CONNECT_WALLET_ERROR),s(e)}},p=Ze(Yt)?kt({address:c.address,appConfig:Yt,methodScreen:pt.FUNDING_METHOD_SELECTION_SCREEN,fundWalletConfig:r,comingFromSendTransactionScreen:!0}):void 0;ea({connectWallet:h,sendSolanaTransaction:{transactionRequest:e,connection:t,transactionOptions:a,transactingWallet:c,onSuccess:e=>{At(pa,"sendSolanaTransaction","onSuccess",{response:e}),o(e)},onFailure:e=>{At(pa,"sendSolanaTransaction","onError",Se.TRANSACTION_FAILURE),s(e)},uiOptions:n||{},requesterAppId:l},funding:p}),Aa(pt.EMBEDDED_WALLET_CONNECTING_SCREEN)}}));function Qa(){return new Promise((async(e,t)=>{let a=await Fa();if(!a||!qt)throw Error("Must have valid access token to enroll in MFA");try{await qt.verifyMfa({accessToken:a}),e()}catch(e){t(e)}}))}let Ja=e=>e?.linkedAccounts.filter((e=>null!==e.latestVerifiedAt&&!("wallet"===e.type&&"privy"===e.walletClientType))).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0],Za=e=>{let t=re?.linkedAccounts.filter((t=>t.type===e)).length??0,{displayName:a,loginMethod:r}=ot(e);if("passkey"===e&&t>=5||"passkey"!==e&&t>=1)throw At(pa,"linkAccount","onError",Se.CANNOT_LINK_MORE_OF_TYPE,{linkMethod:r}),new be(`User already has an account of type ${a} linked.`)};async function er({showAutomaticRecovery:e=!1,legacySetWalletPasswordFlow:t=!1}){St(null);let a=t?"setWalletPassword":"setWalletRecovery";if(!z||!re)throw At(pa,a,"onError",Se.MUST_BE_AUTHENTICATED),Error("User must be authenticated before adding recovery method to Privy wallet");let r=N(re);if(!r||!qt)throw At(pa,a,"onError",Se.EMBEDDED_WALLET_NOT_FOUND),Error("Must have a Privy wallet to add a recovery method");try{await Qa()}catch(e){throw At(pa,a,"onError",Se.MISSING_MFA_CREDENTIALS),e}return new Promise(((n,i)=>{Jt(!0);let o={onSuccess:e=>{At(pa,a,"onSuccess",{method:"user-passcode",wallet:e}),n(e)},onFailure:e=>{At(pa,a,"onError",Se.USER_EXITED_SET_PASSWORD_FLOW),i(e)},callAuthOnSuccessOnClose:!1},s="user-passcode"===r.recoveryMethod,l=Xe({walletAction:"update",availableRecoveryMethods:Yt.embeddedWallets.userOwnedRecoveryOptions,legacySetWalletPasswordFlow:t,isResettingPassword:s,showAutomaticRecovery:e}),{entropyId:c,entropyIdVerifier:d}=C(r);ea({setWalletPassword:o,recoverWallet:{entropyId:c,entropyIdVerifier:d,onFailure:i},createWallet:o,connectWallet:{onCompleteNavigateTo:l,shouldForceMFA:!1,entropyId:c,entropyIdVerifier:d,onFailure:e=>{At(pa,a,"onError",Se.UNKNOWN_CONNECT_WALLET_ERROR),i(e)}},recoverySelection:{isInAccountCreateFlow:!1,isResettingPassword:s}}),Aa(pt.EMBEDDED_WALLET_CONNECTING_SCREEN)}))}async function tr({appId:e,action:t}){let a=await Fa();if("link"===t&&!a)throw At(pa,"linkAccount","onError",Se.MUST_BE_AUTHENTICATED,{linkMethod:`privy:${e}`}),new be("User must be authenticated before linking an account.");if("login"===t&&a)throw At(pa,"login","onError",Se.UNKNOWN_AUTH_ERROR),new be("Attempted to log in, but user is already logged in. Use a `link` helper instead.");ya.current=`privy:${e}`,ga.current=t;let r=tt();return v.createAnalyticsEvent({eventName:"cross_app_auth_started",payload:{providerAppId:e}}),new Promise((async(a,n)=>{let{name:i,logoUrl:o}=await Ke({api:v.api,providerAppId:e,requesterAppId:Yt.id});ea({crossAppAuth:{appId:e,name:i,logoUrl:o,action:t,popup:r,onSuccess:a,onError:n}}),_a(pt.CROSS_APP_AUTH_SCREEN)}))}let ar={ready:B,authenticated:z,user:re,walletConnectors:v.connectors||null,connectWallet:e=>{e&&"target"in e&&e&&(e=void 0),ea({externalConnectWallet:{walletList:e?.walletList&&e?.walletList.length>0?e.walletList:void 0,suggestedAddress:e?.suggestedAddress}}),Aa(z?pt.CONNECT_ONLY_AUTHENTICATED_SCREEN:pt.CONNECT_ONLY_LANDING_SCREEN)},linkWallet:()=>{ja("siwe"),ya.current="siwe",ga.current="link",Aa(pt.LINK_WALLET_SCREEN)},startCrossAppAuthFlow:tr,linkEmail:()=>{ja("email"),Za("email"),ya.current="email",ga.current="link",Aa(pt.LINK_EMAIL_SCREEN)},linkPhone:()=>{ja("sms"),Za("phone"),ya.current="sms",ga.current="link",Aa(pt.LINK_PHONE_SCREEN)},linkGoogle:async()=>{ja("google"),Za("google_oauth"),ga.current="link",await rr.initLoginWithOAuth("google")},linkTwitter:async()=>{ja("twitter"),Za("twitter_oauth"),ga.current="link",await rr.initLoginWithOAuth("twitter")},linkDiscord:async()=>{ja("discord"),Za("discord_oauth"),ga.current="link",await rr.initLoginWithOAuth("discord")},linkGithub:async()=>{ja("github"),Za("github_oauth"),ga.current="link",await rr.initLoginWithOAuth("github")},linkSpotify:async()=>{ja("spotify"),Za("spotify_oauth"),ga.current="link",await rr.initLoginWithOAuth("spotify")},linkInstagram:async()=>{ja("instagram"),Za("instagram_oauth"),ga.current="link",await rr.initLoginWithOAuth("instagram")},linkTiktok:async()=>{ja("tiktok"),Za("tiktok_oauth"),ga.current="link",await rr.initLoginWithOAuth("tiktok")},linkLinkedIn:async()=>{ja("linkedin"),Za("linkedin_oauth"),ga.current="link",await rr.initLoginWithOAuth("linkedin")},linkApple:async()=>{ja("apple"),Za("apple_oauth"),ga.current="link",await rr.initLoginWithOAuth("apple")},linkPasskey:async()=>{ja("passkey"),Za("passkey"),await rr.initLinkWithPasskey(),Aa(pt.LINK_PASSKEY_SCREEN)},linkTelegram:async e=>{if(ja("telegram"),Za("telegram"),ga.current="link",ya.current="telegram",e?.launchParams)if(e.launchParams.initDataRaw){let t=new E;v.startAuthFlow(t),t.meta.telegramAuthResult=void 0,t.meta.telegramWebAppData=A(e.launchParams.initDataRaw),ea({telegramAuthModalData:{seamlessAuth:!0}}),_a(pt.TELEGRAM_AUTH_SCREEN)}else At(pa,"linkAccount","onError",Se.INVALID_DATA,{linkMethod:"telegram"});else await rr.initLoginWithTelegram();Aa(pt.TELEGRAM_AUTH_SCREEN)},linkFarcaster:async()=>{ja("farcaster"),Za("farcaster"),await rr.initLoginWithFarcaster(),ga.current="link",ya.current="farcaster",Aa(pt.AWAITING_FARCASTER_CONNECTION)},updateEmail:()=>{if(ja("email"),!re?.email)throw new be("User does not have an email linked to their account.");ga.current="update",ya.current="email",Aa(pt.UPDATE_EMAIL_SCREEN)},updatePhone:()=>{if(ja("sms"),!re?.phone)throw new be("User does not have a phone number linked to their account.");ga.current="update",ya.current="sms",Aa(pt.UPDATE_PHONE_SCREEN)},login:async e=>{e&&"target"in e&&e&&(e=void 0);let t="Attempted to log in, but user is already logged in. Use a `link` helper instead.";if(!B){let e=await new Promise((e=>{aa((t=>e.bind(t)))}));if(aa(null),e)return void console.warn(t)}!re||re.isGuest?(ga.current="login",ea({login:e}),_a(pt.LANDING)):console.warn(t)},connectOrCreateWallet:async()=>{B||(await new Promise((e=>{aa((()=>e))})),aa(null)),z?console.warn("User must be unauthenticated to `connectOrCreateWallet`"):(ga.current="login",_a(pt.CONNECT_OR_CREATE))},logout:async()=>{if(ga.current=null,ya.current=null,re&&v.clearProviderAcccessTokens(re),St(null),await v.logout(),re&&qt)try{await qt.clearMfa({userId:re.id})}catch(e){}ie(null),G(!1),At(pa,"logout","onSuccess"),j(!1),Z.del(K),Z.del(q(Yt.id))},getAccessToken:()=>v.getCustomerAccessToken(),unlinkWallet:async e=>{let t;return ie(t=e.startsWith("0x")?await v.unlinkEthereumWallet(e):await v.unlinkSolanaWallet(e)),t},unlinkEmail:async e=>{let t=await v.unlinkEmail(e);return ie(t),t},unlinkPhone:async e=>{let t=await v.unlinkPhone(e);return ie(t),t},unlinkGoogle:async e=>{let t=await v.unlinkOAuth("google",e);return ie(t),t},unlinkTwitter:async e=>{let t=await v.unlinkOAuth("twitter",e);return ie(t),t},unlinkDiscord:async e=>{let t=await v.unlinkOAuth("discord",e);return ie(t),t},unlinkGithub:async e=>{let t=await v.unlinkOAuth("github",e);return ie(t),t},unlinkSpotify:async e=>{let t=await v.unlinkOAuth("spotify",e);return ie(t),t},unlinkInstagram:async e=>{let t=await v.unlinkOAuth("instagram",e);return ie(t),t},unlinkTiktok:async e=>{let t=await v.unlinkOAuth("tiktok",e);return ie(t),t},unlinkLinkedIn:async e=>{let t=await v.unlinkOAuth("linkedin",e);return ie(t),t},unlinkApple:async e=>{let t=await v.unlinkOAuth("apple",e);return ie(t),t},unlinkFarcaster:async e=>{let t=await v.unlinkFarcaster(e);return ie(t),t},unlinkTelegram:async e=>{let t=await v.unlinkTelegram(e);return ie(t),t},unlinkPasskey:async e=>{let t=await v.unlinkPasskey(e);return ie(t),t},unlinkCrossAppAccount:async({subject:e})=>{let t=re?.linkedAccounts.find((t=>"cross_app"===t.type&&t.subject===e))?.providerApp;if(!t)throw new be("Invalid subject");v.storeProviderAccessToken(t.id,null);let a=await v.unlinkOAuth(`privy:${t.id}`,e);return ie(a),a},createWallet:async e=>{e&&"target"in e&&e&&(e=void 0);let t=await rr.refreshUser();if(!z||!t)throw At(pa,"createWallet","onError",Se.MUST_BE_AUTHENTICATED),Error("User must be authenticated before creating a Privy wallet");return Ka(t,15e3,e)},setWalletRecovery:async e=>er({legacySetWalletPasswordFlow:!1,showAutomaticRecovery:e?.showAutomaticRecovery??!1}),setWalletPassword:async()=>er({legacySetWalletPasswordFlow:!0,showAutomaticRecovery:!1}),signMessage:(e,t)=>new Promise((async(a,r)=>{let{requesterAppId:n}=t?.uiOptions||{},i=e.message;if(!z||!re)return At(pa,"signMessage","onError",Se.MUST_BE_AUTHENTICATED),void r(Error("User must be authenticated before signing with a Privy wallet"));let o=t?.address??b(re)?.address;if(!o)throw new be("User must have an embedded wallet to sign a message.");let{signingWallet:s,rootWallet:l}=M(re,o);if(!s||!l)return At(pa,"signMessage","onError",Se.EMBEDDED_WALLET_NOT_FOUND),void r(Error("Must have a Privy wallet before signing"));if("string"!=typeof i||i.length<1)return At(pa,"signMessage","onError",Se.INVALID_MESSAGE),void r(Error("Message must be a non-empty string"));Jt(!0);let c=async()=>{if(!z)throw Error("User must be authenticated before signing with a Privy wallet");let e=await Fa();if(!qt||!e||!await rr.recoverPrimaryWallet())throw Error("Unable to connect to wallet");v.createAnalyticsEvent({eventName:"embedded_wallet_sign_message_started",payload:{walletAddress:s.address,requesterAppId:n}});let{entropyId:t,entropyIdVerifier:a}=C(l),{response:r}=await qt.rpc({accessToken:e,entropyId:t,entropyIdVerifier:a,chainType:"ethereum",hdWalletIndex:s.walletIndex??0,requesterAppId:n,request:{method:"personal_sign",params:[i,s.address]}}),o=r.data;return v.createAnalyticsEvent({eventName:"embedded_wallet_sign_message_completed",payload:{walletAddress:s.address,requesterAppId:n}}),o};if(Ea({showWalletUIs:t?.uiOptions?.showWalletUIs}))try{let e=await c();At(pa,"signMessage","onSuccess",{signature:e}),a({signature:e})}catch(e){At(pa,"signMessage","onError",Se.UNABLE_TO_SIGN),r(e??new me("Unable to sign message"))}else{let e={method:"personal_sign",data:i,confirmAndSign:c,onSuccess:e=>{At(pa,"signMessage","onSuccess",{signature:e}),a({signature:e})},onFailure:e=>{At(pa,"signMessage","onError",Se.UNABLE_TO_SIGN),r(e)},uiOptions:t?.uiOptions||{}},{entropyId:n,entropyIdVerifier:o}=C(l);ea({signMessage:e,connectWallet:{entropyId:n,entropyIdVerifier:o,onCompleteNavigateTo:pt.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:e=>{At(pa,"signMessage","onError",Se.UNKNOWN_CONNECT_WALLET_ERROR),r(e)}}}),Aa(pt.EMBEDDED_WALLET_CONNECTING_SCREEN)}})),signTypedData:(e,t)=>new Promise((async(a,r)=>{let{requesterAppId:n}=t?.uiOptions||{};if(!z||!re)return At(pa,"signTypedData","onError",Se.MUST_BE_AUTHENTICATED),void r(Error("User must be authenticated before signing with a Privy wallet"));let i=t?.address??b(re)?.address;if(!i)throw new be("User must have an embedded wallet to sign a message.");let{signingWallet:o,rootWallet:s}=M(re,i);if(!s||!o)return At(pa,"signTypedData","onError",Se.EMBEDDED_WALLET_NOT_FOUND),void r(Error("Must have a Privy wallet before signing"));Jt(!0);let l=te(e),c=async()=>{if(!z)throw Error("User must be authenticated before signing with a Privy wallet");let e=await Fa();if(!qt||!e||!await rr.recoverPrimaryWallet())throw Error("Unable to connect to wallet");v.createAnalyticsEvent({eventName:"embedded_wallet_sign_typed_data_started",payload:{walletAddress:o.address,requesterAppId:n}});let{entropyId:t,entropyIdVerifier:a}=C(s),{response:r}=await qt.rpc({accessToken:e,entropyId:t,entropyIdVerifier:a,chainType:"ethereum",hdWalletIndex:o.walletIndex??0,requesterAppId:n,request:{method:"eth_signTypedData_v4",params:[o.address,l]}}),i=r.data;return v.createAnalyticsEvent({eventName:"embedded_wallet_sign_typed_data_completed",payload:{walletAddress:o.address,requesterAppId:n}}),i};if(Ea({showWalletUIs:t?.uiOptions?.showWalletUIs}))try{let e=await c();At(pa,"signTypedData","onSuccess",{signature:e}),a({signature:e})}catch(e){At(pa,"signTypedData","onError",Se.UNABLE_TO_SIGN),r(e??new me("Unable to sign message"))}else{let e={method:"eth_signTypedData_v4",data:l,confirmAndSign:c,onSuccess:e=>{At(pa,"signTypedData","onSuccess",{signature:e}),a({signature:e})},onFailure:e=>{At(pa,"signTypedData","onError",Se.UNABLE_TO_SIGN),r(e)},uiOptions:t?.uiOptions||{}},{entropyId:n,entropyIdVerifier:i}=C(s);ea({signMessage:e,connectWallet:{entropyId:n,entropyIdVerifier:i,onCompleteNavigateTo:pt.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:e=>{At(pa,"signMessage","onError",Se.UNKNOWN_CONNECT_WALLET_ERROR),r(e)}}}),Aa(pt.EMBEDDED_WALLET_CONNECTING_SCREEN)}})),sendTransaction:async(e,t)=>await Ya({transaction:e,uiOptions:t?.uiOptions,fundWalletConfig:t?.fundWalletConfig,address:t?.address,signOnly:!1}),signTransaction:async(e,t)=>({signature:(await Ya({transaction:e,uiOptions:t?.uiOptions,address:t?.address,signOnly:!0})).hash}),exportWallet:e=>new Promise((async(t,a)=>{if(!z||!re)return void a(Error("User must be authenticated before exporting their Privy wallet"));e&&"target"in e&&e&&(e=void 0);let r=e?.address??b(re)?.address;if(!r)return void a(Error("User does not have an HD Ethereum wallet. To export an imported wallet, pass the `address` of the wallet to `exportWallet`."));let{signingWallet:n,rootWallet:i}=M(re,r);if(!n||!i)return void a(Error("Must have a Privy wallet before exporting"));Jt(!0);let{entropyId:o,entropyIdVerifier:s}=C(i),l={entropyId:o,entropyIdVerifier:s,onCompleteNavigateTo:pt.EMBEDDED_WALLET_KEY_EXPORT_SCREEN,onFailure:a,shouldForceMFA:!0};ea(Zt),await Fa()&&qt?qt?(ea({keyExport:{appId:T.appId,appClientId:T.clientId,origin:v.apiUrl,walletToExport:n,primaryWallet:i,onSuccess:t,onFailure:a},connectWallet:l}),Aa(pt.EMBEDDED_WALLET_CONNECTING_SCREEN)):a(Error("Must have a Privy wallet before exporting")):a(Error("Must have valid access token to enroll in MFA"))})),promptMfa:Qa,async init(e){switch(e){case"sms":return void await v.initMfaSmsVerification();case"passkey":return await v.initMfaPasskeyVerification();case"totp":return;default:throw Error(`Unsupported MFA method: ${e}`)}},async submit(e,t){switch(e){case"totp":case"sms":if("string"!=typeof t)throw new be("Invalid MFA code");ua.current?.resolve({mfaMethod:e,mfaCode:t,relyingParty:window.origin}),await new Promise(((e,t)=>{ha.current={resolve:e,reject:t}}));break;case"passkey":if("string"==typeof t)throw new be("Invalid authenticator response");let a=await import("@simplewebauthn/browser"),r=lt(await a.startAuthentication(t));ua.current?.resolve({mfaMethod:e,mfaCode:r,relyingParty:window.origin}),await new Promise(((e,t)=>{ha.current={resolve:e,reject:t}}));break;default:throw ua.current?.reject(new be("Unsupported MFA method")),new be(`Unsupported MFA method: ${e}`)}},cancel(){ua.current?.reject(new be("MFA canceled"))},async initEnrollmentWithSms(e){let t=await Fa();if(!t||!qt)throw Error("Must have valid access token to enroll in MFA");await qt.initEnrollMfa({method:"sms",accessToken:t,phoneNumber:e.phoneNumber})},enrollInMfa:e=>new Promise(((t,a)=>{if(!e)return rr.closePrivyModal(),void t();Yt.mfa.noPromptOnMfaRequired&&console.warn("[Privy Warning] Triggering the 'showMfaEnrollmentModal' function when 'noPromptOnMfaRequired' is set to true is unexpected. If this is intentional, ensure that you are building custom UIs for MFA verification."),ea({mfaEnrollmentFlow:{mfaMethods:Yt.mfa.methods,onSuccess:t,onFailure:a}}),Aa(pt.MFA_ENROLLMENT_FLOW_SCREEN)})),async initEnrollmentWithTotp(){let e=await Fa();if(!e||!qt)throw Error("Must have valid access token to enroll in MFA");let t=await qt.initEnrollMfa({method:"totp",accessToken:e});return{secret:t.secret,authUrl:t.authUrl}},async submitEnrollmentWithSms(e){let t=await Fa();if(!t||!qt)throw Error("Must have valid access token to enroll in MFA");await qt.submitEnrollMfa({method:"sms",accessToken:t,phoneNumber:e.phoneNumber,code:e.mfaCode}),ie(await v.getAuthenticatedUser())},async submitEnrollmentWithTotp(e){let t=await Fa();if(!t||!qt)throw Error("Must have valid access token to enroll in MFA");await qt.submitEnrollMfa({method:"totp",accessToken:t,code:e.mfaCode}),ie(await v.getAuthenticatedUser())},async initEnrollmentWithPasskey(){},async submitEnrollmentWithPasskey({credentialIds:e}){let t=await Fa();if(!t||!qt)throw Error("Must have valid access token to enroll in MFA");await qt.submitEnrollMfa({method:"passkey",accessToken:t,credentialIds:e}),ie(await v.getAuthenticatedUser())},async unenroll(e){let t=await Fa();if(!t||!qt)throw Error("Must have valid access token to remove MFA");"passkey"===e?await qt.submitEnrollMfa({method:"passkey",accessToken:t,credentialIds:[]}):await qt.unenrollMfa({method:e,accessToken:t}),ie(await v.getAuthenticatedUser())},requestFarcasterSignerFromWarpcast:async()=>{let e=await Fa(),t=re?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!e)throw Error("Must have valid access token to connect with Farcaster");if(!qt||!t)throw Error("Must have an embedded wallet to use Farcaster signers");if(!re?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await rr.recoverPrimaryWallet())throw Error("Unable to connect to wallet");let a=await qt.initFarcasterSigner({address:t.address,hdWalletIndex:null,accessToken:e,mfaCode:null,mfaMethod:null,relyingParty:window.origin});"approved"===a.status&&ie(await v.getAuthenticatedUser()||re||null),ea({farcasterSigner:a}),Aa(pt.AWAITING_FARCASTER_SIGNER)},getFarcasterSignerPublicKey:async()=>{let e,t=await Fa(),a=re?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!qt||!a)throw Error("Must have an embedded wallet to use Farcaster signers");if(!re?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await rr.recoverPrimaryWallet())throw Error("Unable to connect to wallet");if(!re.farcaster?.signerPublicKey)throw Error("Must have a Farcaster signer public key to sign");return e=re.farcaster.signerPublicKey.slice(2),Uint8Array.from(e.match(/.{1,2}/g).map((e=>parseInt(e,16))))},signFarcasterMessage:async e=>{let t=await Fa(),a=re?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!qt||!a)throw Error("Must have an embedded wallet to use Farcaster signers");if(!re?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await rr.recoverPrimaryWallet())throw Error("Unable to connect to wallet");if(!re.farcaster?.signerPublicKey)throw Error("Must have a Farcaster signer public key to sign");let r=await import("@simplewebauthn/browser"),n=await qt.signFarcasterMessage({address:a.address,hdWalletIndex:null,accessToken:t,mfaCode:null,mfaMethod:null,payload:{hash:r.bufferToBase64URLString(e)},fid:BigInt(re.farcaster.fid),relyingParty:window.origin});return new Uint8Array(r.base64URLStringToBuffer(n.signature))},createGuestAccount:async()=>{if(re&&!re.isGuest)throw Error("User cannot already be authenticated to create a guest account");return re?.isGuest?re:rr.loginWithGuestAccountFlow()},signMessageWithCrossAppWallet(e,{address:t}){let a=re?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t))));return Ge({user:re,client:v,address:t,requesterAppId:Yt.id,request:{method:a?"privy_signSmartWalletMessage":"personal_sign",params:[e,t]},reconnect:tr})},signTypedDataWithCrossAppWallet(e,{address:t}){let a=re?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t)))),r=te(e);return Ge({user:re,client:v,address:t,requesterAppId:Yt.id,request:{method:a?"privy_signSmartWalletTypedData":"eth_signTypedData_v4",params:[t,r]},reconnect:tr})},sendTransactionWithCrossAppWallet(e,{address:t}){let a=re?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t))));return Ge({user:re,client:v,address:t,requesterAppId:Yt.id,request:{method:a?"privy_sendSmartWalletTx":"eth_sendTransaction",params:[e]},reconnect:tr})},isModalOpen:x,mfaMethods:Yt.mfa.methods};Ua=ar.signMessage,Oa=ar.signTypedData,Ra=async(e,t)=>await Ya({transaction:e,...t,signOnly:!1}),Sa=async(e,t)=>({signature:(await Ya({transaction:e,...t,signOnly:!0})).hash});let rr={setAuthenticated:G,setUser:ie,isNewUserThisSession:ct,pendingTransaction:null,walletConnectionStatus:Dt,connectors:v.connectors?.walletConnectors??[],solanaWallets:ue,rpcConfig:Yt.rpcConfig,chains:Yt.chains,appId:T.appId,showFiatPrices:"native-token"!==Yt.embeddedWallets.priceDisplay.primary,clientAnalyticsId:v.clientAnalyticsId,customAuthStatus:ca,hideWalletUIs:fa,emailOtpState:xt,setEmailOtpState:jt,smsOtpState:Bt,setSmsOtpState:Vt,oAuthState:zt,setOAuthState:Gt,siweState:Ht,setSiweState:Kt,isHeadlessOAuthLoading:Rt,nativeTokenSymbolForChainId:e=>Yt.chains.find((t=>t.id===Number(e)))?.nativeCurrency.symbol,initializeWalletProxy:async e=>{if(qt)return qt;let t=new Promise((e=>{na((()=>t=>e(t)))})),a=new Promise((t=>setTimeout((()=>t(null)),e))),r=await Promise.race([t,a]);return na(null),r},getAuthFlow:()=>v.authFlow,getAuthMeta:()=>v.authFlow?.meta,client:v,closePrivyModal:async(e={shouldCallAuthOnSuccess:!0,isSuccess:!1})=>{let t,a=B&&z&&re;a&&ya.current&&(t=Ja(re)),"login"===ga.current?e.shouldCallAuthOnSuccess&&a&&ya.current?At(pa,"login","onComplete",{user:re,isNewUser:ct,wasAlreadyAuthenticated:!1,loginMethod:ya.current,loginAccount:t??null}):At(pa,"login","onError",Se.USER_EXITED_AUTH_FLOW):"link"===ga.current&&t?e.isSuccess&&a&&ya.current?At(pa,"linkAccount","onSuccess",{user:re,linkMethod:ya.current,linkedAccount:t}):ya.current&&At(pa,"linkAccount","onError",Se.USER_EXITED_LINK_FLOW,{linkMethod:ya.current}):"update"===ga.current&&t&&(e.isSuccess&&a&&ya.current?At(pa,"update","onSuccess",{user:re,updateMethod:ya.current,updatedAccount:t}):ya.current&&At(pa,"update","onError",Se.USER_EXITED_UPDATE_FLOW,{linkMethod:ya.current}));let r=Ot&&Qe.includes(Ot),n=Ot===pt.ERROR_SCREEN&&Zt.errorModalData&&Qe.includes(Zt.errorModalData.previousScreen);if((r||n)&&Zt.funding){let e,t=Je[Ot]??null;if("solana"===Zt.funding.chainType){let a=I(ut);if(!a)return void console.warn("Unable to load solana plugin, skipping balance");try{e=BigInt(await a.getBalance({address:Zt.funding.address,cluster:Zt.funding.cluster}))}catch{console.error("Unable to pull wallet balance")}At(pa,"fundSolanaWallet","onUserExited",{address:Zt.funding.address,cluster:Zt.funding.cluster,fundingMethod:t,balance:e})}else{let a=yt(Zt.funding.chain.id,Yt.chains,Yt.rpcConfig,{appId:T.appId});try{e=await a.getBalance({address:Zt.funding.address})}catch{console.error("Unable to pull wallet balance")}At(pa,"fundWallet","onUserExited",{address:Zt.funding.address,chain:Zt.funding.chain,fundingMethod:t,balance:e})}}ea({...Zt,externalConnectWallet:{suggestedAddress:void 0}}),ga.current=null,ya.current=null,Ut(!1),j(!1),setTimeout((()=>{v.authFlow=void 0}),200),v.createAnalyticsEvent({eventName:"modal_closed"})},solanaSignMessage:({message:e,address:t})=>new Promise((async(a,r)=>{if(!z||!re)return At(pa,"signMessage","onError",Se.MUST_BE_AUTHENTICATED),void r(Error("User must be authenticated before signing with a Privy wallet"));let n=t??R(re)?.address;if(!n)throw new be("User must have an embedded wallet to sign a message.");let{signingWallet:i,rootWallet:o}=D(re,n);if(!i||!o)return At(pa,"signMessage","onError",Se.EMBEDDED_WALLET_NOT_FOUND),void r(Error("Must have a Privy wallet before signing"));if("string"!=typeof e||e.length<1)return At(pa,"signMessage","onError",Se.INVALID_MESSAGE),void r(Error("Message must be a non-empty string"));Jt(!0);let s=async()=>{if(!z)throw Error("User must be authenticated before signing with a Privy wallet");let t=await v.getAccessToken();if(!t)throw Error("User must be authenticated to use their embedded wallet.");let a=rr.walletProxy??await rr.initializeWalletProxy(15e3);if(!a)throw Error("Failed to initialize embedded wallet proxy.");if(!await rr.recoverPrimaryWallet())throw Error("Unable to connect to wallet");if(!o)throw Error("No root wallet for signing wallet found");let{entropyId:r,entropyIdVerifier:n}=C(o),{response:s}=await a.rpc({accessToken:t,entropyId:r,entropyIdVerifier:n,chainType:"solana",hdWalletIndex:i.walletIndex??0,request:{method:"signMessage",params:{message:e}}});return s.data.signature};if(Ea({showWalletUIs:void 0}))try{let e=await s();a({signature:e})}catch(e){r(e)}else{let{entropyId:t,entropyIdVerifier:n}=C(o);ea({signMessage:{method:"solana_signMessage",data:e,confirmAndSign:s,onSuccess:e=>{a({signature:e})},onFailure:e=>{r(e)},uiOptions:{}},connectWallet:{entropyId:t,entropyIdVerifier:n,onCompleteNavigateTo:pt.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:e=>{At(pa,"signMessage","onError",Se.UNKNOWN_CONNECT_WALLET_ERROR),r(e)}}}),_a(pt.EMBEDDED_WALLET_CONNECTING_SCREEN)}})),sendSolanaTransaction:async({transaction:e,connection:t,uiOptions:a,transactionOptions:r,fundWalletConfig:n,address:i})=>{let o=i?Ue.find((e=>e.address===i)):Ue.slice().sort(((e,t)=>(e.walletIndex??0)-(t.walletIndex??0)))[0];if(!o)throw At(pa,"sendSolanaTransaction","onError",Se.EMBEDDED_WALLET_NOT_FOUND),new be("Embedded wallet not found",Se.EMBEDDED_WALLET_NOT_FOUND);return await Xa({transaction:e,connection:t,transactionOptions:r,uiOptions:a,fundWalletConfig:n,wallet:o})},openPrivyModal:Aa,connectWallet:ka,initLoginWithWallet:async(e,t,a)=>{ge(e)?(ya.current="siwe",Wa(e,t,a)):(ya.current="siws",La(e,t,a))},loginWithWallet:async()=>{let e,t,a;if(!B)throw new Re;if(v.authFlow instanceof m?e="siwe":v.authFlow instanceof y&&(e="siws"),!e)throw new be("Must initialize SIWE/SIWS flow first.");if(null!==await v.getAccessToken())try{({user:t}=await v.link()),ya.current=e}catch(t){throw At(pa,"linkAccount","onError",t.privyErrorCode||Se.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}else try{({user:t,isNewUser:a}=await v.authenticate()),ya.current=e}catch(e){throw At(pa,"login","onError",e.privyErrorCode||Se.GENERIC_CONNECT_WALLET_ERROR),e}ie(t||re||null),Ut(a||!1),G(!0)},delegateWallet:async({address:e,chainType:t,showDelegationUIs:a})=>new Promise((async(r,n)=>{let i=await Fa();if(!z||!re||!i)throw new be("User must be authenticated and have an embedded wallet to delegate actions.");if("solana"!==t&&"ethereum"!==t)throw new be("Only Solana and Ethereum embedded wallets are supported for delegation and revocation.");let o=rr.walletProxy??await rr.initializeWalletProxy(15e3);if(!o)throw new be("Wallet proxy not initialized.");if(Te({address:e,chainType:t,user:re}))return r();let s=ve({address:e,user:re}),l=Ce({address:e,user:re}),c=async()=>{await o.createDelegatedAction({accessToken:i,rootWallet:l,delegatedWallets:[s]}),await rr.refreshUser()};if(!a){try{await c(),r()}catch(e){n(e)}return}await rr.recoverPrimaryWallet(),ea({delegatedActions:{consent:{address:e,onDelegate:c,onSuccess:async()=>{r()},onError:async e=>{n(e)}}}}),Aa(pt.EMBEDDED_WALLET_DELEGATED_ACTIONS_CONSENT_SCREEN)})),revokeDelegatedWallets:async({showDelegationUIs:e})=>new Promise((async(t,a)=>{if(!z||!re)throw new be("User must be authenticated and have an embedded wallet to revoke a delegated wallet.");if(0===Ie(re).length)throw new be("User has no delegated wallets to revoke.");let r=async()=>{await v.revokeDelegatedWallet(),await rr.refreshUser()};if(e)ea({delegatedActions:{revoke:{onRevoke:r,onSuccess:async()=>{t()},onError:async e=>{a(e)}}}}),Aa(pt.EMBEDDED_WALLET_DELEGATED_ACTIONS_REVOKE_SCREEN);else try{await r(),t()}catch(e){a(e)}})),initLoginWithFarcaster:async(e,t)=>{let a=new h(e,t);v.startAuthFlow(a);try{ya.current="farcaster",await a.initializeFarcasterConnect()}catch(e){throw"login"===ga.current?At(pa,"login","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR):"link"===ga.current&&At(pa,"linkAccount","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR,{linkMethod:"farcaster"}),e}},loginWithFarcaster:async()=>{let e,t;if(!B)throw new Re;if(!(v.authFlow instanceof h))throw new be("Must initialize Farcaster flow first.");if(null!==await v.getAccessToken())try{({user:e}=await v.link()),ya.current="farcaster"}catch(e){throw At(pa,"linkAccount","onError",e.privyErrorCode||Se.FAILED_TO_LINK_ACCOUNT,{linkMethod:"farcaster"}),e}else try{({user:e,isNewUser:t}=await v.authenticate()),ya.current="farcaster"}catch(e){throw At(pa,"login","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR),e}ie(e||null),Ut(t||!1),G(!0)},async loginWithGuestAccountFlow(){let e=new p(this.appId);v.startAuthFlow(e);try{ga.current="login",ya.current="guest";let{user:e,isNewUser:t}=await v.authenticate();if(t=t||!1,!e)throw new be("Unable to authenticate guest account");if(S(e,Yt.embeddedWallets.createOnLogin))try{await Ka(e,15e3),e=await rr.refreshUser()}catch(t){ie(e),console.warn("Unable to create embedded wallet for guest account")}else ie(e);return Ut(t),G(!0),At(pa,"login","onComplete",{user:e,isNewUser:t,wasAlreadyAuthenticated:!1,loginMethod:"guest",loginAccount:null}),e}catch(e){throw At(pa,"login","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR),e}},async crossAppAuthFlow({appId:e,popup:t,action:a}){let r=`privy:${e}`;ya.current=r;let{url:n,stateCode:i,codeVerifier:o}=await Ve({api:v.api,appId:e});if(!n)throw v.createAnalyticsEvent({eventName:"cross_app_auth_error",payload:{error:"Unable to open cross-app auth popup",appId:e}}),new be("No authorization URL returned for cross-app auth.");try{let s=await ze({url:n,popup:t,provider:r}),l=s.stateCode,c=s.authorizationCode;if(l!==i)throw v.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:r,storedStateCode:i??"",returnedStateCode:l??""}}),new be("Unexpected auth flow. This may be a phishing attempt.",void 0,Se.OAUTH_UNEXPECTED);let d=await He({appId:e,codeVerifier:o,stateCode:l,authorizationCode:c,action:a,client:v});d&&v.storeProviderAccessToken(e,d);let u=await rr.refreshUser();if(!u)throw new be("Unable to update user");return v.createAnalyticsEvent({eventName:"cross_app_auth_completed",payload:{providerAppId:e}}),u}catch(e){throw v.createAnalyticsEvent({eventName:"cross_app_auth_error",payload:{error:e.toString(),provider:r}}),e}},async initLoginWithOAuth(e,t,a){if(ya.current=e,!ee())return void _a(pt.IN_APP_BROWSER_LOGIN_NOT_POSSIBLE);if("google"===e&&et(window.navigator.userAgent))return void _a(pt.IN_APP_BROWSER_LOGIN_NOT_POSSIBLE);"twitter"===e&&window.opener&&window.opener.postMessage({type:xe},"*"),Z.del($),Z.del(Y);let r=new bt({provider:e,disableSignup:!!a,withPrivyUi:!0});t&&r.addCaptchaToken(t),v.startAuthFlow(r);let n=await v.authFlow.getAuthorizationUrl();n&&n.url&&("twitter"===e&&s&&(n.url=n.url.replace("x.com","twitter.com")),window.location.assign(n.url))},async initLoginWithTelegram(e,t){if(!B)throw new Re;ya.current="telegram";let a=new E(e,t);v.startAuthFlow(a),a.meta.telegramWebAppData=void 0,a.meta.telegramAuthResult=await new Promise(((e,t)=>Yt.loginConfig.telegramAuthConfiguration?window.Telegram?void window.Telegram.Login.auth({bot_id:Yt.loginConfig.telegramAuthConfiguration.botId,request_access:!0},(a=>a?e(a):t(new be("Telegram auth failed or was canceled by the client")))):t(new be("Telegram was not initialized")):t(new be("Telegram Auth configuration is not loaded"))))},async loginWithTelegram(e){let t,a;if(!(v.authFlow instanceof E))throw new be("Must initialize Telegram flow before calling loginWithTelegram");if(v.authFlow.meta.captchaToken||=e,"login"===ga.current)try{let e=await v.authenticate();t=e.user,a=e.isNewUser,ya.current="telegram"}catch(e){throw At(pa,"login","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR),e}else{if("link"!==ga.current)throw new be("Unknown auth intent");try{t=(await v.link()).user,ya.current="telegram"}catch(e){throw At(pa,"linkAccount","onError",e.privyErrorCode||Se.FAILED_TO_LINK_ACCOUNT,{linkMethod:"telegram"}),e}}ie(t),Ut(a||!1),G(!0)},async recoveryOAuthFlow(e,t,a){let r,n;function i(t){if(!t)throw v.createAnalyticsEvent({eventName:"recovery_oauth_error",payload:{error:"Unable to open recovery OAuth popup",provider:e}}),new be("Recovery OAuth failed")}switch(e){case"google-drive":{let t,o,{url:s,codeVerifier:l,stateCode:c}=await qe({api:ba.api,provider:e});i(s);try{let r=await at({url:s,popup:a,provider:e});if(t=r.stateCode,o=r.authorizationCode,t!==c)throw v.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e,storedStateCode:c??"",returnedStateCode:t??""}}),new be("Unexpected auth flow. This may be a phishing attempt.",void 0,Se.OAUTH_UNEXPECTED)}catch(t){throw v.createAnalyticsEvent({eventName:"recovery_oauth_error",payload:{error:t.toString(),provider:e}}),new be("Recovery OAuth failed")}[r,n]=await Promise.all([Fa(),$e({api:ba.api,provider:e,codeVerifier:l,stateCode:t,authorizationCode:o})]);break}case"icloud":{let{url:t}=await qe({api:ba.api,provider:e});i(t);let{ckWebAuthToken:o}=await at({url:t,popup:a,provider:e});n=o,r=await Fa()}}if(!qt)throw new be("Cannot connect to wallet proxy");if(!r)throw new be("Unable to authorize user");switch(t){case"recover":{let t=Zt.recoverWallet?.entropyId,a=Zt.recoverWallet?.entropyIdVerifier;if(!t||!a)throw new be("Recovery OAuth failed");v.createAnalyticsEvent({eventName:"embedded_wallet_recovery_started",payload:{walletAddress:t,recoveryMethod:e}}),await qt.recover({accessToken:r,entropyId:t,entropyIdVerifier:a,recoveryAccessToken:n}),v.createAnalyticsEvent({eventName:"embedded_wallet_recovery_completed",payload:{walletAddress:t,recoveryMethod:e}});break}case"create-wallet":{v.createAnalyticsEvent({eventName:"embedded_wallet_creation_started"}),await qt.create({accessToken:r,recoveryAccessToken:n,recoveryMethod:e});let t=b(await rr.refreshUser());if(!t)throw At(pa,"createWallet","onError",Se.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to create wallet");v.createAnalyticsEvent({eventName:"embedded_wallet_creation_completed",payload:{walletAddress:t.address}}),At(pa,"createWallet","onSuccess",{wallet:t});break}case"set-recovery":{let t=N(re);if(!t)throw At(pa,"setWalletRecovery","onError",Se.EMBEDDED_WALLET_NOT_FOUND),Error("Embedded wallet not found");v.createAnalyticsEvent({eventName:"embedded_wallet_set_recovery_started",payload:{walletAddress:t.address,existingRecoveryMethod:t.recoveryMethod,targetRecoveryMethod:e}});let{entropyId:a,entropyIdVerifier:i}=C(t);await qt.setRecovery({accessToken:r,entropyId:a,entropyIdVerifier:i,recoveryMethod:e,recoveryAccessToken:n});let o=N(await rr.refreshUser());if(!o)throw At(pa,"createWallet","onError",Se.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to set recovery on wallet");v.createAnalyticsEvent({eventName:"embedded_wallet_set_recovery_completed",payload:{walletAddress:t.address,existingRecoveryMethod:t.recoveryMethod,targetRecoveryMethod:e}}),At(pa,"setWalletRecovery","onSuccess",{method:e,wallet:o});break}default:throw new be("Unsupported recovery action")}},async loginWithOAuth(e){let t,a,r;if(!(v.authFlow instanceof bt))throw new be("Must initialize OAuth flow before calling loginWithOAuth");let n=Z.get(X),i=v.authFlow.meta.stateCode;if(n!==i)throw v.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e,storedStateCode:n??"",returnedStateCode:i??""}}),new be("Unexpected auth flow. This may be a phishing attempt.",void 0,Se.OAUTH_UNEXPECTED);if(null!==await v.getAccessToken())try{let a=await v.link();t=a.user,r=a.oAuthTokens,ya.current=e}catch(t){throw At(pa,"linkAccount","onError",t.privyErrorCode||Se.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}else try{let n=await v.authenticate();t=n.user,a=n.isNewUser,r=n.oAuthTokens,ya.current=e}catch(t){throw"login"===ga.current?At(pa,"login","onError",t.privyErrorCode||Se.UNKNOWN_AUTH_ERROR):"link"===ga.current&&At(pa,"linkAccount","onError",t.privyErrorCode||Se.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}return ie(t),Ut(a||!1),G(!0),r&&t&&At(pa,"oAuthAuthorization","onOAuthTokenGrant",{oAuthTokens:r,user:t}),r},passkeyAuthState:Lt,setPasskeyAuthState:Ft,async initSignupWithPasskey({captchaToken:e,withPrivyUi:t}){let a=new w({captchaToken:e,setPasskeyAuthState:Ft});v.startAuthFlow(a),ga.current="login";try{ya.current="passkey",Ft({status:"generating-challenge"}),await a.initRegisterFlow(t),Ft({status:"awaiting-passkey"})}catch(e){throw Ft({status:"error",error:e}),At(pa,"login","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR),e}},async signupWithPasskey(){let e,t;if(!B)throw new Re;if(!(v.authFlow instanceof w))throw new be("Must initialize Passkey flow first.");if("passkey"!==ya.current){let e=new be("Must init login with Passkey flow first.");throw Ft({status:"error",error:e}),e}let a=await Fa();try{ya.current="passkey",Ft({status:"awaiting-passkey"}),({user:e,isNewUser:t}=await v.authenticate())}catch(e){throw Ft({status:"error",error:e}),At(pa,"login","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR),e}ie(e),Ut(t||!1),G(!0),Ft({status:"done"});let r=e?.linkedAccounts.find((({type:e})=>"passkey"===e))||null;return{user:e,isNewUser:t||!1,wasAlreadyAuthenticated:!!a,loginAccount:r}},async initLoginWithPasskey({captchaToken:e,withPrivyUi:t}){let a=new w({captchaToken:e,setPasskeyAuthState:Ft});v.startAuthFlow(a),ga.current="login";try{ya.current="passkey",Ft({status:"generating-challenge"}),await a.initAuthenticationFlow(t),Ft({status:"awaiting-passkey"})}catch(e){throw Ft({status:"error",error:e}),At(pa,"login","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR),e}},async loginWithPasskey(){let e,t;if(!B)throw new Re;if(!(v.authFlow instanceof w))throw new be("Must initialize Passkey flow first.");if("passkey"!==ya.current){let e=new be("Must init login with Passkey flow first.");throw Ft({status:"error",error:e}),e}let a=await Fa();try{ya.current="passkey",Ft({status:"awaiting-passkey"}),({user:e,isNewUser:t}=await v.authenticate())}catch(e){throw Ft({status:"error",error:e}),At(pa,"login","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR),e}ie(e),Ut(t||!1),G(!0),Ft({status:"done"});let r=e?.linkedAccounts.find((({type:e})=>"passkey"===e))||null;return{user:e,isNewUser:t||!1,wasAlreadyAuthenticated:!!a,loginAccount:r}},async initLinkWithPasskey(e){let t=new w({captchaToken:e});v.startAuthFlow(t),ga.current="link",ya.current="passkey",Ft({status:"generating-challenge"});try{await t.initLinkFlow(),Ft({status:"awaiting-passkey"})}catch(e){throw At(pa,"linkAccount","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR,{linkMethod:"passkey"}),Ft({status:"error",error:e}),e}},async linkWithPasskey(){let e;if(!B)throw new Re;if(!(v.authFlow instanceof w))throw new be("Must initialize Passkey flow first.");if("passkey"!==ya.current)throw new be("Must init login with Passkey flow first.");try{ya.current="passkey",({user:e}=await v.link())}catch(e){throw At(pa,"linkAccount","onError",e.privyErrorCode||Se.FAILED_TO_LINK_ACCOUNT,{linkMethod:"passkey"}),e}return ie(e||re||null),Ft({status:"done"}),e},async initLoginWithHeadlessOAuth(e,t,a){if(!ee())throw Error("It looks like you're using an in-app browser.  To log in, please try again using an external browser.");if("google"===e&&et(window.navigator.userAgent))throw Error("It looks like you're using an in-app browser.  To log in, please try again using an external browser.");let r=new bt({provider:e,withPrivyUi:!1,disableSignup:a??!1});t&&r.addCaptchaToken(t),Gt({status:"loading"});let n=await v.startAuthFlow(r).getAuthorizationUrl();n?.url&&window.location.assign(n.url)},async loginWithHeadlessOAuth(e){let t,a,r;Pt(!0),Gt({status:"loading"}),v.startAuthFlow(new bt(e));let n=Z.get(X),i=e.stateCode;if(n!==i)throw v.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e.provider,storedStateCode:n??"",returnedStateCode:i??""}}),Pt(!1),new be("Unexpected auth flow. This may be a phishing attempt.",void 0,Se.OAUTH_UNEXPECTED);if(null!==await v.getAccessToken())try{({user:t,oAuthTokens:r}=await v.link()),ya.current=e.provider;let a=Ja(t);t&&a&&At(pa,"linkAccount","onSuccess",{user:t,linkMethod:ya.current,linkedAccount:a})}catch(t){throw Pt(!1),At(pa,"linkAccount","onError",t.privyErrorCode||Se.FAILED_TO_LINK_ACCOUNT,{linkMethod:e.provider}),t}else try{({user:t,isNewUser:a,oAuthTokens:r}=await v.authenticate()),ya.current=e.provider;let n=Ja(t);t&&n&&void 0!==a&&At(pa,"login","onComplete",{user:t,isNewUser:a,wasAlreadyAuthenticated:!1,loginMethod:ya.current,loginAccount:n})}catch(e){throw Pt(!1),Gt({status:"error",error:e}),At(pa,"login","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR),e}return ie(t),Ut(a||!1),G(!0),Pt(!1),Gt({status:"done"}),r&&t&&At(pa,"oAuthAuthorization","onOAuthTokenGrant",{oAuthTokens:r,user:t}),t??void 0},initLoginWithEmail:async({email:e,captchaToken:t,disableSignup:a,withPrivyUi:r})=>{let n=new u({email:e,captchaToken:t,disableSignup:a});v.startAuthFlow(n);try{ya.current="email",jt({status:"sending-code"}),await n.sendCodeEmail({withPrivyUi:r}),jt({status:"awaiting-code-input"})}catch(e){throw jt({status:"error",error:e}),"login"===ga.current?At(pa,"login","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR):"link"===ga.current&&At(pa,"linkAccount","onError",e.privyErrorCode||Se.FAILED_TO_LINK_ACCOUNT,{linkMethod:"email"}),e}},initUpdateEmail:async(e,t,a)=>{let r=new d(e,t,a);v.startAuthFlow(r);try{await r.sendCodeEmail({withPrivyUi:!0})}catch(e){At(pa,"update","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR,{linkMethod:ya.current})}},initUpdatePhone:async(e,t,a)=>{let r=new g(e,t,a);v.startAuthFlow(r);try{await r.sendSmsCode({withPrivyUi:!0})}catch(e){At(pa,"update","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR,{linkMethod:ya.current})}},initLoginWithSms:async({phoneNumber:e,captchaToken:t,disableSignup:a,withPrivyUi:r})=>{Vt({status:"sending-code"});let n=new f({phoneNumber:e,captchaToken:t,disableSignup:a});v.startAuthFlow(n);try{ya.current="sms",await n.sendSmsCode({withPrivyUi:r}),Vt({status:"awaiting-code-input"})}catch(e){throw Vt({status:"error",error:e}),"login"===ga.current?At(pa,"login","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR):"link"===ga.current&&At(pa,"linkAccount","onError",e.privyErrorCode||Se.FAILED_TO_LINK_ACCOUNT,{linkMethod:"sms"}),e}},resendEmailCode:async()=>{await(v.authFlow?.sendCodeEmail({withPrivyUi:!0}))},resendSmsCode:async()=>{await(v.authFlow?.sendSmsCode({withPrivyUi:!0}))},loginWithCode:async e=>{let t,a;function r(e){v.authFlow instanceof u?jt(e):v.authFlow instanceof f&&Vt(e)}if(r({status:"submitting-code"}),!B){let e=new Re;throw r({status:"error",error:e}),e}if(v.authFlow instanceof u)v.authFlow.meta.emailCode=e.trim();else{if(!(v.authFlow instanceof f)){let e=new be("Must initialize a passwordless code flow first");throw r({status:"error",error:e}),e}v.authFlow.meta.smsCode=e.trim()}let n=await Fa();if("link"===ga.current)try{({user:t}=await v.link())}catch(e){throw r({status:"error",error:e}),At(pa,"linkAccount","onError",e.privyErrorCode||Se.FAILED_TO_LINK_ACCOUNT,{linkMethod:ya.current}),e}else if("update"===ga.current)try{({user:t}=await v.link())}catch(e){throw r({status:"error",error:e}),At(pa,"update","onError",e.privyErrorCode||Se.FAILED_TO_UPDATE_ACCOUNT,{linkMethod:ya.current}),e}else try{({user:t,isNewUser:a}=await v.authenticate())}catch(e){throw r({status:"error",error:e}),At(pa,"login","onError",e.privyErrorCode||Se.UNKNOWN_AUTH_ERROR),e}let i=t||re;ie(i||null),Ut(a||!1),G(!0),r({status:"done"});let o=null;return v.authFlow instanceof u?o=i?.linkedAccounts.find((({type:e})=>"email"===e))||null:v.authFlow instanceof f&&(o=i?.linkedAccounts.find((({type:e})=>"phone"===e))||null),{user:i,isNewUser:a||!1,wasAlreadyAuthenticated:!!n,linkedAccount:o}},generateSiweMessage:async({address:e,chainId:t,captchaToken:a})=>{ga.current="link",ya.current="siwe",Kt({status:"generating-message"});let r=await v.generateSiweNonce({address:e,captchaToken:a});return Kt({status:"awaiting-signature"}),rt({address:e,chainId:t.replace("eip155:",""),nonce:r})},generateSiweMessageForSmartWallet:async({address:e,chainId:t})=>{let a=await v.generateSiweNonce({address:e});return rt({address:e,chainId:t.replace("eip155:",""),nonce:a})},linkSmartWallet:async({message:e,signature:t,smartWalletType:a})=>{let r;r=await v.linkSmartWallet({message:e,signature:t,smartWalletType:a}),ie((r=await rr.refreshUser()??r)||re||null)},linkWithSiwe:async({message:e,signature:t,chainId:a,walletClientType:r,connectorType:n})=>{let i;ja("siwe");let o=null;try{Kt({status:"submitting-signature"}),i=await v.linkWithSiwe({message:e,signature:t,chainId:a,walletClientType:r,connectorType:n}),i=await rr.refreshUser()??i,Kt({status:"done"}),(o=Ja(i)||null)&&At(pa,"linkAccount","onSuccess",{user:i,linkMethod:"siwe",linkedAccount:o})}catch(e){throw At(pa,"linkAccount","onError",e.privyErrorCode||Se.FAILED_TO_LINK_ACCOUNT,{linkMethod:"siwe"}),ga.current=null,ya.current=null,Kt({status:"error",error:e}),e}let s=i||re;return ie(s||null),ga.current=null,ya.current=null,{user:s,linkedAccount:o}},refreshUser:async()=>{let e=await v.getAuthenticatedUser();return G(!!e),ie(e),e},walletProxy:qt,createAnalyticsEvent:({eventName:e,payload:t,timestamp:a})=>v.createAnalyticsEvent({eventName:e,payload:t,timestamp:a}),acceptTerms:async()=>{let e=await v.acceptTerms();return ie(e),e},getUsdTokenPrice:e=>v.getUsdTokenPrice(e),getUsdPriceForSol:()=>v.getUsdPriceForSol(),getSplTokenMetadata:e=>v.getSplTokenMetadata(e),recoverPrimaryWallet:async e=>new Promise((async(t,a)=>{let r=N(e?.user??re)||O(e?.user??re)||W(e?.user??re),n=await Fa();if(!n||!qt||!r)return void a(Error("Must have valid access token and Privy wallet to recover wallet"));Jt(!0);let{entropyId:i,entropyIdVerifier:o}=C(r);try{await qt.connect({accessToken:n,entropyId:i,entropyIdVerifier:o}),t(!0)}catch(e){ke(e)&&"privy"===r.recoveryMethod?(v.createAnalyticsEvent({eventName:"embedded_wallet_pinless_recovery_started",payload:{walletAddress:r.address}}),(await qt.recover({entropyId:i,entropyIdVerifier:o,accessToken:n})).entropyId||a(Error("Unable to recover wallet")),v.createAnalyticsEvent({eventName:"embedded_wallet_recovery_completed",payload:{walletAddress:r.address}}),t(!0)):ke(e)&&"privy"!==r.recoveryMethod?(ea({recoverWallet:{entropyId:i,entropyIdVerifier:o,onFailure:a,onSuccess:()=>t(!0)},recoveryOAuthStatus:{provider:r.recoveryMethod,action:"recover"}}),Aa(Ye(r.recoveryMethod))):a(e)}})),embeddedSolanaWallets:Ue,createEmbeddedSolanaWallet:async e=>{e&&"target"in e&&(e=void 0);let t=await rr.refreshUser();if(!z||!t)throw At(pa,"createWallet","onError",Se.MUST_BE_AUTHENTICATED),Error("User must be authenticated before creating a Privy wallet");return(async(e,t,a)=>{let r=b(e),n=R(e),i=a&&"createAdditional"in a&&a.createAdditional,o=a&&"walletIndex"in a?a.walletIndex:void 0,s=(L(e)?.walletIndex??-1)+1;if(n&&!i&&"number"!=typeof o)throw At(pa,"createWallet","onError",Se.EMBEDDED_WALLET_ALREADY_EXISTS),Error("User already has an embedded wallet.");if("number"==typeof o&&o<0)throw At(pa,"createWallet","onError",Se.EMBEDDED_WALLET_CREATE_ERROR),Error(`A negative walletIndex (${o}) is invalid.`);let[l,c]=await Promise.all([rr.initializeWalletProxy(t),Fa()]);if(!l||!c)throw At(pa,"createWallet","onError",Se.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");return await qa({user:e,wp:l,accessToken:c,walletIndex:o??s,ethereumWallet:r})})(t,15e3,e)},exportSolanaWallet:e=>new Promise((async(t,a)=>{if(!z||!re)return void a(Error("User must be authenticated before exporting their Privy wallet"));let r=e?.address??R(re)?.address;if(!r)return void a(Error("User does not have an HD Solana wallet."));let{signingWallet:n,rootWallet:i}=D(re,r);if(!n||!i)return void a(Error("Must have a Privy wallet before exporting"));if(Jt(!0),!await Fa()||!qt)return void a(Error("Must have valid access token to enroll in MFA"));if(!qt)return void a(Error("Must have a Privy wallet before exporting"));let{entropyId:o,entropyIdVerifier:s}=C(i);ea({connectWallet:{entropyId:o,entropyIdVerifier:s,onCompleteNavigateTo:pt.EMBEDDED_WALLET_KEY_EXPORT_SCREEN,onFailure:a,shouldForceMFA:!0},keyExport:{appId:T.appId,appClientId:T.clientId,origin:v.apiUrl,walletToExport:n,primaryWallet:i,onSuccess:t,onFailure:a}}),Aa(pt.EMBEDDED_WALLET_CONNECTING_SCREEN)})),setReadyToTrue:e=>{H(!0),ta?.(e)},updateWallets:()=>Ha(),fundWallet:async(e,t)=>{let a=pt.FUNDING_METHOD_SELECTION_SCREEN;ea({funding:Wt({address:e,appConfig:Yt,fundWalletConfig:t,methodScreen:a})}),Aa(a)},openModal:Aa,requestFarcasterSignerStatus:async e=>{let t=await Fa(),a=re?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!qt||!a)throw Error("Must have an embedded wallet to use Farcaster signers");if(!re?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");let r=await v.requestFarcasterSignerStatus(e);return"approved"===r.status&&ie(await v.getAuthenticatedUser()||re||null),r},connectCoinbaseSmartWallet:async()=>{Yt.externalWallets.coinbaseWallet.connectionOptions="smartWalletOnly";let e=v.connectors?.findWalletConnector("coinbase_wallet","coinbase_smart_wallet")||v.connectors?.findWalletConnector("coinbase_wallet","coinbase_wallet");if(e)return e.updateConnectionPreference("smartWalletOnly"),ka(e);await Ia("coinbase_wallet","coinbase_smart_wallet")},initiateAccountTransfer:async({nonce:e,account:t,accountType:a,externalWalletMetadata:r,telegramAuthResult:n,telegramWebAppData:i,farcasterEmbeddedAddress:o,oAuthUserInfo:s})=>{let l=await v.sendAccountTransferRequest({nonce:e,account:t,accountType:a,externalWalletMetadata:r,telegramAuthResult:n,telegramWebAppData:i,farcasterEmbeddedAddress:o,oAuthUserInfo:s});return ie(l),l}};Pa=rr.recoverPrimaryWallet,Da=rr.recoverPrimaryWallet,Ma=rr.solanaSignMessage;let nr=o((()=>({wallets:oe,ready:ia&&wa})),[oe,ia,wa]),ir=v.authFlow instanceof E,or=!Yt.headless&&Yt.captchaEnabled&&!z&&(B||ir);/*#__PURE__*/return e(Ct.Provider,{value:ar,children:/*#__PURE__*/e(_t.Provider,{value:pa,children:/*#__PURE__*/e(It.Provider,{value:nr,children:/*#__PURE__*/e(ft,{...Yt,children:/*#__PURE__*/t(Tt.Provider,{value:rr,children:[/*#__PURE__*/e(ht,{children:/*#__PURE__*/t(vt,{data:Zt,setModalData:ea,setInitialScreen:St,initialScreen:Ot,authenticated:z,open:x,children:[T.children,or&&/*#__PURE__*/e(le,{delayedExecution:!1}),/*#__PURE__*/e(mt,{theme:{...Yt.appearance.palette||{}}}),!Yt.render.standalone&&/*#__PURE__*/e(ce,{open:x})]})}),Qt&&Xt?/*#__PURE__*/e(_e,{appId:T.appId,appClientId:T.clientId,clientAnalyticsId:v.clientAnalyticsId,origin:v.apiUrl,mfaMethods:re?.mfaMethods,mfaPromise:ua,mfaSubmitPromise:ha,onLoad:$t,onLoadFailed:()=>null}):null,Yt.loginConfig.telegramAuthConfiguration&&
/*#__PURE__*/e(wt,{$if:!0,children:/*#__PURE__*/e(de,{scriptHost:T.apiUrl||V,botUsername:Yt.loginConfig.telegramAuthConfiguration.botName})})]})})})})})};export{_a as C,Aa as E,Ga as P,ka as a,Na as b,Fa as c,xa as d,ja as e,Ba as f,La as g,Va as h,Ha as i,Ka as j,za as k,Ta as l};

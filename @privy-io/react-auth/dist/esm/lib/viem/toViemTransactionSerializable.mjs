import{isHex as e,toHex as a}from"viem";import{PrivyClientError as r}from"../../errors.mjs";import"ofetch";let s={0:"legacy",1:"eip2930",2:"eip1559",3:"eip4844"};const i={legacy:0,eip2930:1,eip1559:2,eip4844:3};let t=e=>void 0!==e?BigInt(e):void 0;function o(i){let o,{type:c=2,...d}=i;d.accessList&&Array.isArray(d.accessList)?o=d.accessList.map((e=>Array.isArray(e)?{address:e[0],storageKeys:e[1]}:e)):d.accessList&&(o=Object.entries(d.accessList).map((e=>({address:e[0],storageKeys:e[1]}))));let n=Number(d.chainId??1),m=e(d.data)?d.data:d.data?a(Uint8Array.from(d.data)):void 0,p=d.nonce?Number(d.nonce):void 0,y={chainId:n,data:m,nonce:p,value:t(d.value),gas:t(d.gas??d.gasLimit)};if(0===c)return{...d,type:s[c],...y,gasPrice:t(d.gasPrice),accessList:void 0,maxFeePerGas:void 0,maxPriorityFeePerGas:void 0};if(1===c)return{...d,type:s[c],...y,gasPrice:t(d.gasPrice),accessList:o,maxFeePerGas:void 0,maxPriorityFeePerGas:void 0};if(2===c)return{...d,type:s[c],...y,nonce:p,accessList:o,maxFeePerGas:t(d.maxFeePerGas),maxPriorityFeePerGas:t(d.maxPriorityFeePerGas),gasPrice:void 0,maxFeePerBlobGas:void 0};throw new r(`Unsupported transaction type: ${c}`)}export{i as STRING_TO_NUMBER_TXN_TYPE,o as toViemTransactionSerializable};
